{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u2693\ufe0e For full documentation visit mkdocs.org . Commands \u2693\ufe0e Note mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u2693\ufe0e 1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 from rurple import * def parcourir_ligne (): \"Parcourt une ligne\" while not mur_devant (): avance () #parcourir_ligne() def tour_grille ( n ): \"Effectue n tours d'une grille rectangulaire\" for i in range ( n ): for j in range ( 4 ): parcourir_ligne () gauche () def tour_grille2 ( n ): \"Effectue n tours d'une grille rectangulaire\" for i in range ( 4 * n ): parcourir_ligne () gauche () #tour_grille(6) def mystere (): \"Ramasse toutes les billes sur une case\" while bille_au_sol (): prends () #mystere() def aspirateur_ligne (): \"Ramasse toutes les billes sur une ligne\" mystere () while not mur_devant (): avance () mystere () #aspirateur_ligne() def droite (): \"Fait tourner le robot \u00e0 droite\" for k in range ( 3 ): gauche () def quart_tour ( ligne ): if ligne % 2 == 1 : gauche () else : droite () def aspirateur_grille (): \"Ramasse toutes les billes sur une grille\" ligne = 1 aspirateur_ligne () quart_tour ( ligne ) while not mur_devant (): avance () quart_tour ( ligne ) aspirateur_ligne () ligne = ligne + 1 quart_tour ( ligne ) #aspirateur_grille() def demi_tour (): gauche () gauche () def bille_devant (): \"D\u00e9termine si la case devant contient une bille\" avance () reponse = bille_au_sol () demi_tour () avance () demi_tour () return reponse def petit_poucet (): \"\"\"Le robot parcourt toutes les cases d'une grille carr\u00e9 nxn avec n impair et d\u00e9pose 1 billes sur chaque case \"\"\" while bille_en_poche (): depose () if mur_devant () or bille_devant (): gauche () if not bille_devant (): avance () petit_poucet () Math\u00e9matiques \u2693\ufe0e \\(\\frac{a^{12}}{b}\\)","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"Note mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 from rurple import * def parcourir_ligne (): \"Parcourt une ligne\" while not mur_devant (): avance () #parcourir_ligne() def tour_grille ( n ): \"Effectue n tours d'une grille rectangulaire\" for i in range ( n ): for j in range ( 4 ): parcourir_ligne () gauche () def tour_grille2 ( n ): \"Effectue n tours d'une grille rectangulaire\" for i in range ( 4 * n ): parcourir_ligne () gauche () #tour_grille(6) def mystere (): \"Ramasse toutes les billes sur une case\" while bille_au_sol (): prends () #mystere() def aspirateur_ligne (): \"Ramasse toutes les billes sur une ligne\" mystere () while not mur_devant (): avance () mystere () #aspirateur_ligne() def droite (): \"Fait tourner le robot \u00e0 droite\" for k in range ( 3 ): gauche () def quart_tour ( ligne ): if ligne % 2 == 1 : gauche () else : droite () def aspirateur_grille (): \"Ramasse toutes les billes sur une grille\" ligne = 1 aspirateur_ligne () quart_tour ( ligne ) while not mur_devant (): avance () quart_tour ( ligne ) aspirateur_ligne () ligne = ligne + 1 quart_tour ( ligne ) #aspirateur_grille() def demi_tour (): gauche () gauche () def bille_devant (): \"D\u00e9termine si la case devant contient une bille\" avance () reponse = bille_au_sol () demi_tour () avance () demi_tour () return reponse def petit_poucet (): \"\"\"Le robot parcourt toutes les cases d'une grille carr\u00e9 nxn avec n impair et d\u00e9pose 1 billes sur chaque case \"\"\" while bille_en_poche (): depose () if mur_devant () or bille_devant (): gauche () if not bille_devant (): avance () petit_poucet ()","title":"Project layout"},{"location":"#mathematiques","text":"\\(\\frac{a^{12}}{b}\\)","title":"Math\u00e9matiques"},{"location":"section/","text":"Welcome to MkDocs \u2693\ufe0e For full documentation visit mkdocs.org . Commands \u2693\ufe0e Note mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u2693\ufe0e 1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 from rurple import * def parcourir_ligne (): \"Parcourt une ligne\" while not mur_devant (): avance () #parcourir_ligne() def tour_grille ( n ): \"Effectue n tours d'une grille rectangulaire\" for i in range ( n ): for j in range ( 4 ): parcourir_ligne () gauche () def tour_grille2 ( n ): \"Effectue n tours d'une grille rectangulaire\" for i in range ( 4 * n ): parcourir_ligne () gauche () #tour_grille(6) def mystere (): \"Ramasse toutes les billes sur une case\" while bille_au_sol (): prends () #mystere() def aspirateur_ligne (): \"Ramasse toutes les billes sur une ligne\" mystere () while not mur_devant (): avance () mystere () #aspirateur_ligne() def droite (): \"Fait tourner le robot \u00e0 droite\" for k in range ( 3 ): gauche () def quart_tour ( ligne ): if ligne % 2 == 1 : gauche () else : droite () def aspirateur_grille (): \"Ramasse toutes les billes sur une grille\" ligne = 1 aspirateur_ligne () quart_tour ( ligne ) while not mur_devant (): avance () quart_tour ( ligne ) aspirateur_ligne () ligne = ligne + 1 quart_tour ( ligne ) #aspirateur_grille() def demi_tour (): gauche () gauche () def bille_devant (): \"D\u00e9termine si la case devant contient une bille\" avance () reponse = bille_au_sol () demi_tour () avance () demi_tour () return reponse def petit_poucet (): \"\"\"Le robot parcourt toutes les cases d'une grille carr\u00e9 nxn avec n impair et d\u00e9pose 1 billes sur chaque case \"\"\" while bille_en_poche (): depose () if mur_devant () or bille_devant (): gauche () if not bille_devant (): avance () petit_poucet () Math\u00e9matiques \u2693\ufe0e \\(\\frac{a^{12}}{b}\\)","title":"Welcome to MkDocs"},{"location":"section/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"section/#commands","text":"Note mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"section/#project-layout","text":"1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 from rurple import * def parcourir_ligne (): \"Parcourt une ligne\" while not mur_devant (): avance () #parcourir_ligne() def tour_grille ( n ): \"Effectue n tours d'une grille rectangulaire\" for i in range ( n ): for j in range ( 4 ): parcourir_ligne () gauche () def tour_grille2 ( n ): \"Effectue n tours d'une grille rectangulaire\" for i in range ( 4 * n ): parcourir_ligne () gauche () #tour_grille(6) def mystere (): \"Ramasse toutes les billes sur une case\" while bille_au_sol (): prends () #mystere() def aspirateur_ligne (): \"Ramasse toutes les billes sur une ligne\" mystere () while not mur_devant (): avance () mystere () #aspirateur_ligne() def droite (): \"Fait tourner le robot \u00e0 droite\" for k in range ( 3 ): gauche () def quart_tour ( ligne ): if ligne % 2 == 1 : gauche () else : droite () def aspirateur_grille (): \"Ramasse toutes les billes sur une grille\" ligne = 1 aspirateur_ligne () quart_tour ( ligne ) while not mur_devant (): avance () quart_tour ( ligne ) aspirateur_ligne () ligne = ligne + 1 quart_tour ( ligne ) #aspirateur_grille() def demi_tour (): gauche () gauche () def bille_devant (): \"D\u00e9termine si la case devant contient une bille\" avance () reponse = bille_au_sol () demi_tour () avance () demi_tour () return reponse def petit_poucet (): \"\"\"Le robot parcourt toutes les cases d'une grille carr\u00e9 nxn avec n impair et d\u00e9pose 1 billes sur chaque case \"\"\" while bille_en_poche (): depose () if mur_devant () or bille_devant (): gauche () if not bille_devant (): avance () petit_poucet ()","title":"Project layout"},{"location":"section/#mathematiques","text":"\\(\\frac{a^{12}}{b}\\)","title":"Math\u00e9matiques"},{"location":"section/automatismes/","text":"L'image gif ci-dessous pr\u00e9sente diff\u00e9rentes \u00e9tapes du d\u00e9roulement d'un algorithme de rotation d'images inspir\u00e9 d'un travail pr\u00e9sent\u00e9 par Laurent Abbal du lyc\u00e9e fran\u00e7ais de Tokyo. Le programme assez court peut \u00eatre r\u00e9alis\u00e9 par un \u00e9l\u00e8ve de terminale (r\u00e9cursivit\u00e9, approche diviser pour r\u00e9gner ). L'image source repr\u00e9sente l'oeuvre Matsuri Yatai Dragon du peintre japonais Hokusai . Elle est dans le domaine public et disponible sur https://commons.wikimedia.org . Corrig\u00e9 des automatismes Test 14 \u2693\ufe0e Programmer la fonction dont on donne la sp\u00e9cification : 1 2 3 4 5 6 def index_min ( t ): \"\"\" Param\u00e8tre : t un tableau de nombres (int ou float) Pr\u00e9condition : t non vide Valeur renvoy\u00e9e : un tableau contenant les positions (index) o\u00f9 le minimum de t est atteint \"\"\" Automatisme 2 \u2693\ufe0e Programmer la fonction dont on donne la sp\u00e9cification : 1 2 3 4 5 6 def au_moins_un_zero ( t ): \"\"\" Param\u00e8tre : t un tableau de nombres (int ou float) Pr\u00e9condition : t non vide Valeur renvoy\u00e9e : un bool\u00e9en indiquant si t contient au moins un z\u00e9ro \"\"\" Automatisme 3 \u2693\ufe0e Repr\u00e9senter en binaire le nombre d\u2019\u00e9criture d\u00e9cimale 49. Automatisme 4 \u2693\ufe0e Repr\u00e9senter en base dix, le nombre dont l'\u00e9criture en base deux est 1010110 puis le nombre dont l'\u00e9criture en base 16 est A4 . Automatisme 5 \u2693\ufe0e D\u00e9terminer le successeur des entiers dont l'\u00e9criture en base deux est : 111 10011 10111 Automatisme 6 \u2693\ufe0e Pour d\u00e9terminer la liste des chiffres en base dix d'un entier naturel, un \u00e9l\u00e8ve a \u00e9crit la fonction ci-dessous : 1 2 3 4 5 6 def liste_chiffres ( n ): L = [ n % 10 ] while n > 0 : n = n // 10 L . insert ( 0 , n % 10 ) return L Malheureusement sa fonction ne retourne pas le r\u00e9sultat attendu pour l'entier 730 : 1 2 >>> liste_chiffres(730) [0, 7, 3, 0] Proposer une version corrig\u00e9e de la fonction liste_chiffres . Automatisme 7 \u2693\ufe0e On travaille sur des tableaux \u00e0 deux dimensions qui repr\u00e9sentent des images binaires : un pixel a pour valeur un entier : 0 pour un pixel noir et 1 pour un pixel blanc. Compl\u00e9ter les fonctions ci-dessous en respectant leurs sp\u00e9cifications, les postconditions doivent \u00eatre v\u00e9rifi\u00e9es. Lien vers Basthon pour tester en ligne . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def image_noire ( largeur , hauteur ): \"\"\" Param\u00e8tre : largeur et hauteur deux entiers non nuls Valeur renvoy\u00e9e : un tableau \u00e0 2 dimensions repr\u00e9sentant une image binaire de dimensions (largeur, hauteur) rempli de 0 \"\"\" # \u00e0 compl\u00e9ter avec un tableau en compr\u00e9hension def dimensions ( tab ): \"\"\" Param\u00e8tre : tab un tableau \u00e0 deux dimensions d'entiers repr\u00e9sentant une image binaire rectangulaire Valeur renvoy\u00e9e : un tableau de deux entiers [largeur, hauteur] repr\u00e9sentant les dimensions de l'image \"\"\" # \u00e0 compl\u00e9ter def nombre_blancs ( tab ): \"\"\" Param\u00e8tre : tab un tableau \u00e0 deux dimensions d'entiers repr\u00e9sentant une image binaire rectangulaire Valeur renvoy\u00e9e : un entier repr\u00e9sentant le nombre de pixels blancs (valeur 1) \"\"\" # \u00e0 compl\u00e9ter #postconditions pour la fonction image_noire assert image_noire ( 2 , 1 ) == [[ 0 , 0 ]] assert image_noire ( 1 , 2 ) == [[ 0 ], [ 0 ]] assert image_noire ( 3 , 2 ) == [[ 0 , 0 , 0 ], [ 0 , 0 , 0 ]] #postconditions pour la fonction dimensions assert dimensions ([[], []]) == [ 2 , 0 ] assert dimensions ([[ 0 , 1 , 2 ], [ 3 , 4 , 5 ]]) == [ 2 , 3 ] #postconditions pour la fonction nombre_blancs assert nombre_blancs ([[ 0 , 0 ], [ 0 , 0 ]]) == 0 assert dimensions ([[ 0 , 1 , 1 ], [ 0 , 1 , 0 ]]) == 3 assert dimensions ([[], []]) == 0 Automatisme 8 \u2693\ufe0e Modifier les expressions \"\u00e0 modifier\" dans la fonction Python ci-dessous pour que la sp\u00e9cification soit v\u00e9rifi\u00e9e. Tester le code dans Basthon D\u00e9commenter #test_indice_maximum(indice_maximum) en ligne 63 pour soumettre votre fonction au test unitaire. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def indice_maximum ( tab , debut , fin ): \"\"\" Param\u00e8tres : tab un tableau d'entiers debut un entier indice du d\u00e9but de la plage fin un entier indice de la fin de la plage (inclus) Valeur renvoy\u00e9e : l'indice de la premi\u00e8re occurence du maximum de tab dans la plage de valeurs entre les indice et debut et fin (inclus) \"\"\" imax = \"\u00e0 modifier\" for i in range ( imax + 1 , fin + 1 ): if \"\u00e0 modifier\" : imax = \"\u00e0 modifier\" return imax Automatisme 9 \u2693\ufe0e Modifier les expressions \"\u00e0 modifier\" dans la fonction tri_selection ci-dessous pour que la sp\u00e9cification et l'assertion plac\u00e9e \u00e0 la fin de la boucle externe soient v\u00e9rifi\u00e9s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri_selection ( tab ): \"\"\" Param\u00e8tre : tab un tableau de nombres Valeur renvoy\u00e9e : tab Postcondition : valeur renvoy\u00e9e de tab tri\u00e9e dans l'ordre croissant \"\"\" i = len ( tab ) - 1 while i >= 1 : imax = indice_maximum ( tab , \"\u00e0 modifier\" , \"\u00e0 modifier\" ) tab [ i ], tab [ imax ] = \"\u00e0 modifier\" # assertion qui doit \u00eatre v\u00e9rifi\u00e9e assert max ( tab [: i + 1 ]) == tab [ i ] i = \"\u00e0 modifier\" return tab D\u00e9commenter #test_tri(tri_selection) en ligne 64 pour soumettre votre fonction au test unitaire. Automatisme 10 \u2693\ufe0e Un algorithme de tri d\u2019une liste d\u2019entiers est impl\u00e9ment\u00e9 de la fa\u00e7on suivante : 1 2 3 4 5 6 7 8 9 def trier ( L ) : for i in range ( len ( L )): indice_min = i for j in range ( i + 1 , len ( L )): if L [ j ] < L [ indice_min ] : indice_min = j L [ i ], L [ indice_min ] = L [ indice_min ], L [ i ] # assertion vraie \u00e0 cet endroit return L Parmi les assertions suivantes laquelle reste vraie \u00e0 chaque it\u00e9ration de la boucle, \u00e0 l'endroit indiqu\u00e9 ci-dessus ? R\u00e9ponse A : la sous-liste L[0:i+1] contient les i plus grandes valeurs de L tri\u00e9es par ordre d\u00e9croissant R\u00e9ponse B : la sous-liste L[0:i+1] contient les i plus grandes valeurs de L tri\u00e9es par ordre croissant R\u00e9ponse C : la sous-liste L[0:i+1] contient les i plus petites valeurs de L tri\u00e9es par ordre d\u00e9croissant R\u00e9ponse D : la sous-liste L[0:i+1] contient les i plus petites valeurs de L tri\u00e9es par ordre croissant Automatisme 11 \u2693\ufe0e Compl\u00e9ter la fonction Python ci-dessous pour que la sp\u00e9cification et les postconditions soient satisfaites. Combient de comparaisons sont faites lors de l'appel un_doublon(list(range(100))) ? 1 2 3 4 5 6 7 8 9 10 11 12 13 def un_doublon ( t ): \"\"\" Param\u00e8tre : t un tableau de nombres Valeur renvoy\u00e9e : un bool\u00e9en True si t comporte au moins un doublon False sinon \"\"\" #\u00e0 compl\u00e9ter assert un_doublon ([ 1 , 2 , 3 ]) == False assert un_doublon ([ 1 , 2 , 2 ]) == True assert un_doublon ([ 1 , 2 , 4 , 2 ]) == True assert un_doublon ([]) == False Automatisme 12 \u2693\ufe0e Compl\u00e9ter la fonction Python ci-dessous pour que la sp\u00e9cification et les postconditions soient satisfaites. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def index_premiere_occurence_dicho ( x , t ): \"\"\" Param\u00e8tre : t un tableau de nombres tri\u00e9 dans l'ordre croissant x un nombre Valeur renvoy\u00e9e : l'index de la premi\u00e8re de x dans t si x est dans t -1 sinon \"\"\" a = 0 b = len ( t ) - 1 while a <= b : m = ( a + b ) // 2 if t [ m ] < x : \"\u00e0 compl\u00e9ter\" elif t [ m ] > x : \"\u00e0 compl\u00e9ter\" else : \"\u00e0 compl\u00e9ter\" return \"\u00e0 compl\u00e9ter\" return - 1 assert index_premiere_occurence_dicho ( 10 , [ 10 , 10 , 11 , 12 , 13 ]) == 1 assert index_premiere_occurence_dicho ( 10 , [ 9 , 10 , 11 , 12 , 13 ]) == 1 assert index_premiere_occurence_dicho ( 10 , [ 9 , 9 , 11 , 12 , 13 ]) == - 1 assert index_premiere_occurence_dicho ( 10 , [ 7 , 8 , 9 , 10 ]) == 3 assert index_premiere_occurence_dicho ( 10 , [ 7 , 10 , 10 , 10 , 10 ]) == 1 assert index_premiere_occurence_dicho ( 10 , []) == - 1 Automatisme 13 \u2693\ufe0e Compl\u00e9ter la fonction Python ci-dessous pour que la sp\u00e9cification et les postconditions soient satisfaites. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def est_decroissant ( t ): \"\"\" Param\u00e8tre : t un tableau de nombres Valeur renvoy\u00e9e : bool\u00e9en indiquant si t dans l'ordre d\u00e9croissant \"\"\" \"\u00e0 compl\u00e9ter\" def recherche_dicho_decroissant ( x , t ): \"\"\" Param\u00e8tre : t un tableau de nombres tri\u00e9 dans l'ordre d\u00e9croissant x un nombre Valeur renvoy\u00e9e : index de x dans t si x dans t None si x pas dans t \"\"\" a = 0 b = len ( t ) - 1 while a <= b : m = ( a + b ) // 2 \"\u00e0 compl\u00e9ter\" return None assert est_decroissant ([ k ** 2 for k in range ( 10 )]) == False assert est_decroissant ([]) == True t1 = list ( range ( 10 , - 1 , - 1 )) assert est_decroissant ( t1 ) == True assert recherche_dicho_decroissant ( 8 , t1 ) == 2 assert recherche_dicho_decroissant ( 10 , t1 ) == 0 assert recherche_dicho_decroissant ( 0 , t1 ) == 10 assert recherche_dicho_decroissant ( 4.5 , t1 ) == None print ( \"Test unitaires r\u00e9ussis pour l'automatisme 13 : recherche_dicho_decroissant et est_decroissant\" ) Automatisme 14 \u2693\ufe0e Convertir en flottant au format simple pr\u00e9cision (mantisse sur 8 bits et exposant sur 23 bits), le nombre d'\u00e9criture d\u00e9cimale 9,78125. Convertir en flottant au format simple pr\u00e9cision (mantisse sur 8 bits et exposant sur 23 bits), le nombre d'\u00e9criture d\u00e9cimale 0,1. V\u00e9rifier avec le convertisseur en ligne https://www.h-schmidt.net/FloatConverter/IEEE754.html ou la fonction donn\u00e9e ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def decimal_vers_IEE754 ( x , taille_exposant , taille_mantisse ): #print(\"d\u00e9termination du signe\") if x > 0 : print ( \"Bit de signe : 0\" ) elif x < 0 : print ( \"Bit de signe : 1\" ) else : print ( \"O valeur particuli\u00e8re\" ) if x != 0 : #print(\"d\u00e9termination de l'exposant\") exposant = 0 while int ( x ) >= 1 : x = x / 2 exposant = exposant + 1 while int ( x ) == 0 : x = x * 2 exposant = exposant - 1 decalage = 2 ** ( taille_exposant - 1 ) - 1 print ( \"Exposant en d\u00e9cimal : \" , exposant ) print ( f \"Exposant d\u00e9cal\u00e9 de + { decalage } : \" , exposant + decalage ) print ( f \"Exposant d\u00e9cal\u00e9 de + { decalage } : codage binaire sur 11 bits : \" , bin ( exposant + decalage ) . lstrip ( '0b' ) . zfill ( taille_exposant )) #print(\"d\u00e9termination des bits de mantisse\") x = x - 1 nbits = 0 mantisse = [] while nbits < taille_mantisse : x = x * 2 partie_entiere = int ( x ) mantisse . append ( str ( partie_entiere )) if partie_entiere == 1 : x = x - partie_entiere nbits = nbits + 1 print ( \"Mantisse : \" , '' . join ( mantisse )) Automatisme 15 \u2693\ufe0e On consid\u00e8re une formule bool\u00e9enne form des variables bool\u00e9ennes a et b dont voici la table de v\u00e9rit\u00e9. a b form True True False False True True True False True False False False Quelle est cette formule bool\u00e9enne ? R\u00e9ponse A : a and b R\u00e9ponse B : a or b R\u00e9ponse C : ((not(a)) and b) or (a and (not(b))) R\u00e9ponse D : (not(a)) or (not(b)) Automatisme 16 \u2693\ufe0e Pouvez-vous deviner ce qui va se passer si on ex\u00e9cute le code ci-dessous ? V\u00e9rifiez. Explication ? def boucle1(): x = 1 h = 1 c = 0 while x < 2: h = h / 2 x = x + h c = c + 1 return x == 2, c boucle1() R\u00e9ponse A : (False, 53) R\u00e9ponse B : (True, 53) R\u00e9ponse C : (True, 52) R\u00e9ponse D : la boucle ne se termine pas car d'apr\u00e8s une formule du cours de math\u00e9matiques sur la somme des termes cons\u00e9cutifs d'une suite g\u00e9om\u00e9trique, pour tout entier naturel n on a : <a href=\"https://www.codecogs.com/eqnedit.php?latex=1+1/2+1/2 2+...+1/2 n&space;=&space;(1-1/2 {n+1})/(1-1/2)=2(1-1/2 )<2\" target=\"_blank\"><img src=\"https://latex.codecogs.com/gif.latex?1+1/2+1/2 2+...+1/2 n&space;=&space;(1-1/2 {n+1})/(1-1/2)=2(1-1/2 )<2\" title=\"1+1/2+1/2 2+...+1/2 n = (1-1/2 {n+1})/(1-1/2)=2(1-1/2 )<2\" /> Automatisme 17 ( banque d'\u00e9preuve pratique 2021 ) \u2693\ufe0e \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : 1 2 3 4 5 6 7 8 >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 Automatisme 18 ( banque d'\u00e9preuve pratique 2021 ) \u2693\ufe0e \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : 1 2 >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) Automatisme 19 ( banque d'\u00e9preuve pratique 2021 ) \u2693\ufe0e On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. Compl\u00e9ter la fonction insere ci-dessous. def insere(a, tab): l = list(tab) #l contient les m\u00eames \u00e9l\u00e9ments que tab l.append(a) i = \"\u00e0 compl\u00e9ter\" while i >= 0 and a < \"\u00e0 compl\u00e9ter\" : l[i+1] = \"\u00e0 compl\u00e9ter\" l[i] = a i = \"\u00e0 compl\u00e9ter\" return l assert insere(3,[1,2,4,5]) == [1, 2, 3, 4, 5] assert insere(10,[1,2,7,12,14,25]) == [1, 2, 7, 10, 12, 14, 25] assert insere(1,[2,3,4]) == [1,2,3,4] print('Tests r\u00e9ussis') Automatisme 20 ( banque d'\u00e9preuve pratique 2021 ) \u2693\ufe0e Compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. def dichotomie(tab, x): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len(tab) - 1 while debut < = fin: m = \"\u00e0 compl\u00e9ter\" if x == tab[m]: return \"\u00e0 compl\u00e9ter\" if x > tab[m]: debut = m + 1 else: fin = \"\u00e0 compl\u00e9ter\" return \"\u00e0 compl\u00e9ter\" assert dichotomie([15, 16, 18, 19, 23, 24, 28, 29, 31, 33],28) == True assert dichotomie([15, 16, 18, 19, 23, 24, 28, 29, 31, 33],27) == False print('Tests r\u00e9ussis') Automatisme 21 ( banque d'\u00e9preuve pratique 2021 ) \u2693\ufe0e \u00c9crire une fonction tri_selection qui prend en param\u00e8tre un tableau tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9 dans l'ordre croissant. Exemples de postconditions : 1 2 3 4 >>> assert tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) == [ - 9 , 1 , 6 , 12 , 52 ] >>> assert tri_selection ([]) == [] >>> assert tri_selection ([ 1 , 4 , 8 ]) == [ 1 , 4 , 8 ] >>> assert tri_selection ([ 8 , 4 , 1 ]) == [ 1 , 4 , 8 ] Automatisme 22 ( banque d'\u00e9preuve pratique 2021 ) \u2693\ufe0e Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob, radar, et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s'appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. def inverse_chaine(chaine): result = \"\u00e0 compl\u00e9ter\" for caractere in chaine: result = \"\u00e0 compl\u00e9ter\" return result def est_palindrome(chaine): inverse = inverse_chaine(chaine) return \"\u00e0 compl\u00e9ter\" def est_nbre_palindrome(nbre): chaine = \"\u00e0 compl\u00e9ter\" return est_palindrome(chaine) assert inverse_chaine('bac') == 'cab' assert est_palindrome('NSI') == False assert est_palindrome('ISN-NSI') == True assert est_nbre_palindrome(214312) == False assert est_nbre_palindrome(213312) == True print(\"Tests r\u00e9ussis\") Automatisme 23 ( banque d'\u00e9preuve pratique 2021 ) \u2693\ufe0e Compl\u00e9ter la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. def separe(tab): i = 0 j = \"\u00e0 compl\u00e9ter\" while i < j : if tab[i] == 0 : i = \"\u00e0 compl\u00e9ter\" else : tab[i], tab[j] = \"\u00e0 compl\u00e9ter\" j = \"\u00e0 compl\u00e9ter\" return tab assert separe([1, 0, 1, 0, 1, 0, 1, 0]) == [0, 0, 0, 0, 1, 1, 1, 1] assert separe([1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0]) == [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1] print(\"Tests r\u00e9ussis\") Automatisme 24 ( banque d'\u00e9preuve pratique 2021 ) \u2693\ufe0e \u00c9crire une fonction indice_du_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : 1 2 3 4 5 6 >>> indice_du_min ([ 5 ]) 0 >>> indice_du_min ([ 2 , 4 , 1 ]) 2 >>> indice_du_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 Automatisme 25 : traitement de donn\u00e9es en tables \u2693\ufe0e T\u00e9l\u00e9charger l'archive avec le code source \u00e0 compl\u00e9ter et le fichier eleves.csv . Un corrig\u00e9 est ici . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 #!/usr/bin/env python \"\"\"Consigne : compl\u00e9ter au niveau des \u00e0 \"compl\u00e9ter\" les fonctions : 1) moyenne_table 2) enreg_avec_recompense 3) generer_table_recompenses 4) decompte_recompenses 5) clef_tri_moyenne_decroissant 6) clef_tri_alphabetique_croissant_moyenne_decroissant Chaque fonction est accompagn\u00e9 d'un test unitaire => pour tester, d\u00e9sactiver les commentaires dans le programme principal \u00e0 partir de la ligne 151 Pour les tris il faut aussi compl\u00e9ter le programme principal en lignes 167 et 171 \"\"\" import csv #Import / Export d'un tel fichier CSV ver la repr\u00e9sentation d'une tble en Python (tableau de dictionnaires) def lecture_csv ( fichier , delimiteur ): \"\"\" Param\u00e8tre : un chemin vers un fichier CSV Valeur renvoy\u00e9e : un tableau de dictionnaires, extraction de la table contenue dans le fichier \"\"\" f = open ( fichier , mode = 'r' , encoding = 'utf8' , newline = '' ) reader = csv . DictReader ( f , delimiter = delimiteur ) #cr\u00e9ation de l'objet reader table = [ dict ( enregistrement ) for enregistrement in reader ] f . close () return table def ecriture_csv ( table , fichier , delimiteur ): \"\"\" Param\u00e8tre : un chemin vers un fichier CSV une table comme tableau de dictionnaires partageant les m\u00eames clefs, de valeurs str Valeur renvoy\u00e9e : None, \u00e9crit table dans fichier avec Dictriter du module CSV \"\"\" g = open ( fichier , mode = 'w' , encoding = 'utf8' , newline = '' ) attributs = list ( table [ 0 ] . keys ()) writer = csv . DictWriter ( g , delimiter = delimiteur , fieldnames = attributs ) #cr\u00e9ation de l'objet writer writer . writeheader () #\u00e9criture des attibuts for enregistrement in table : writer . writerow ( enregistrement ) #\u00e9criture des enregistrements g . close () def moyenne_table ( table_eleves ) : \"\"\"Param\u00e8tre : table_eleves est une repr\u00e9sentation de la table extraite de eleves.csv sous forme de tableau de dictionnaires. Attention les attributs 'moyenne' sont de type 'str' Valeur renvoy\u00e9e : un flottant repr\u00e9sentant la moyenne de tous les \u00e9l\u00e8ves de la table arrondie \u00e0 2 chiffres apr\u00e8s la virgule \"\"\" somme = 0 compteur = 0 for enreg in table_eleves : \"\u00e0 compl\u00e9ter\" \"\u00e0 compl\u00e9ter\" return round ( somme / compteur , 2 ) def test_moyenne_table (): assert moyenne_table ( table_eleves ) == 11.46 print ( \"Test unitaire de moyenne_table r\u00e9ussi\" ) def enreg_avec_recompense ( enreg ): \"\"\" Param\u00e8tre : enreg un dictionnaire de clefs 'pr\u00e9nom', 'nom', 'moyenne' Attention toutes les clefs ont des valeurs de type str Valeur renvoy\u00e9e : extension du dictionnaire avec une nouvelle clef 'r\u00e9compense' de valeurs s : 'insuffisant' si moyenne < 8 'm\u00e9diocre' si 8 <= moyenne < 10 'passable' si 10 <= moyenne < 12 'encouragements' si 12 <= moyenne < 14 'compliments' si 14 <= moyenne < 16 'f\u00e9licitations' si moyenne > 16 \"\"\" copie = { clef : valeur for clef , valeur in enreg . items () } m = \"\u00e0 compl\u00e9ter\" if m < 8 : copie [ 'r\u00e9compense' ] = 'insuffisant' elif \"\u00e0 compl\u00e9ter\" : copie [ 'r\u00e9compense' ] = 'm\u00e9diocre' elif \"\u00e0 compl\u00e9ter\" : copie [ 'r\u00e9compense' ] = 'passable' elif \"\u00e0 compl\u00e9ter\" : copie [ 'r\u00e9compense' ] = 'encouragements' elif \"\u00e0 compl\u00e9ter\" : copie [ 'r\u00e9compense' ] = 'compliments' else : copie [ 'r\u00e9compense' ] = 'f\u00e9licitations' return copie def generer_table_recompenses ( table_eleves ): \"\"\"Param\u00e8tre : table_eleves est une repr\u00e9sentation de la table extraite de eleves.csv sous forme de tableau de dictionnaires Valeur renvoy\u00e9e : une extension de table_eleves avec un nouvel attribut 'r\u00e9compense' chaque nouvel enregistrement est g\u00e9n\u00e9r\u00e9 par enreg_avec_recompense \"\"\" table_recompenses = \"\u00e0 compl\u00e9ter\" return table_recompenses def test_generer_table_recompenses (): \"\"\"Test unitaires de generer_table_recompenses\"\"\" table_recompenses = generer_table_recompenses ( table_eleves ) assert table_recompenses [ 0 ] == { 'pr\u00e9nom' : 'Zo\u00e9' , 'nom' : 'Collin' , 'moyenne' : '19' , 'r\u00e9compense' : 'f\u00e9licitations' } assert table_recompenses [ 8 ] == { 'pr\u00e9nom' : 'Roland' , 'nom' : 'Joly' , 'moyenne' : '8' , 'r\u00e9compense' : 'm\u00e9diocre' } print ( \"Test unitaires de generer_table_recompenses r\u00e9ussis\" ) def decompte_recompenses ( table_recompenses ): \"\"\"Param\u00e8tre : table_recompenses est une repr\u00e9sentation de la table renvoy\u00e9e par generer_table_recompenses. Valeur renvoy\u00e9e : un dictionnaire avec le d\u00e9compte de chaque r\u00e9compense \"\"\" decompte = dict () for enreg in table_recompenses : \"\u00e0 compl\u00e9ter\" \"\u00e0 compl\u00e9ter\" \"\u00e0 compl\u00e9ter\" \"\u00e0 compl\u00e9ter\" return decompte def test_decompte_recompenses (): \"\"\"Test unitaires de decompte_recompenses\"\"\" decompte = decompte_recompenses ( table_recompenses ) assert decompte == { 'f\u00e9licitations' : 89 , 'm\u00e9diocre' : 77 , 'compliments' : 95 , 'insuffisant' : 86 , 'passable' : 81 , 'encouragements' : 72 } print ( \"Test unitaires de decompte_recompenses r\u00e9ussis\" ) def clef_tri_moyenne_decroissant ( enreg ): \"\"\"Clef de tri par moyenne d\u00e9croissante Attention la valeur de l'attribut 'moyenne' de enreg est de type str\"\"\" return \"\u00e0 compl\u00e9ter\" def clef_tri_alphabetique_croissant_moyenne_decroissant ( enreg ): \"\"\"Clef de tri par moyenne d\u00e9croissante Attention la valeur de l'attribut 'moyenne' de enreg est de type str\"\"\" return \"\u00e0 compl\u00e9ter\" #Programme principal table_eleves = lecture_csv ( 'eleves.csv' , ',' ) #D\u00e9commenter lorsque moyenne_table est compl\u00e9t\u00e9e #test_moyenne_table() #D\u00e9commenter lorsque generer_table_recompenses est compl\u00e9t\u00e9e #table_recompenses = generer_table_recompenses(table_eleves) #test_generer_table_recompenses() #D\u00e9commenter lorsque decompte_recompenses est compl\u00e9t\u00e9e #test_decompte_recompenses() #D\u00e9commenter e lorsque clef_tri_moyenne_decroissant termin\u00e9e #table_recompenses = generer_table_recompenses(table_eleves) #Ecrire une instruction qui permet de trier table_recompenses dans l'ordre d\u00e9croissant des moyennes #table_tri1 = \"\u00e0 compl\u00e9ter\" #Ecrire une instruction qui permet de trier table_recompenses : #d'abord dans l'ordre alphab\u00e9tique croissant puis dans l'ordre d\u00e9croissant des moyennes #table_tri2 = \"\u00e0 compl\u00e9ter\"","title":"Page 1"},{"location":"section/automatismes/#test-14","text":"Programmer la fonction dont on donne la sp\u00e9cification : 1 2 3 4 5 6 def index_min ( t ): \"\"\" Param\u00e8tre : t un tableau de nombres (int ou float) Pr\u00e9condition : t non vide Valeur renvoy\u00e9e : un tableau contenant les positions (index) o\u00f9 le minimum de t est atteint \"\"\"","title":"Test 14"},{"location":"section/automatismes/#automatisme-2","text":"Programmer la fonction dont on donne la sp\u00e9cification : 1 2 3 4 5 6 def au_moins_un_zero ( t ): \"\"\" Param\u00e8tre : t un tableau de nombres (int ou float) Pr\u00e9condition : t non vide Valeur renvoy\u00e9e : un bool\u00e9en indiquant si t contient au moins un z\u00e9ro \"\"\"","title":"Automatisme 2"},{"location":"section/automatismes/#automatisme-3","text":"Repr\u00e9senter en binaire le nombre d\u2019\u00e9criture d\u00e9cimale 49.","title":"Automatisme 3"},{"location":"section/automatismes/#automatisme-4","text":"Repr\u00e9senter en base dix, le nombre dont l'\u00e9criture en base deux est 1010110 puis le nombre dont l'\u00e9criture en base 16 est A4 .","title":"Automatisme 4"},{"location":"section/automatismes/#automatisme-5","text":"D\u00e9terminer le successeur des entiers dont l'\u00e9criture en base deux est : 111 10011 10111","title":"Automatisme 5"},{"location":"section/automatismes/#automatisme-6","text":"Pour d\u00e9terminer la liste des chiffres en base dix d'un entier naturel, un \u00e9l\u00e8ve a \u00e9crit la fonction ci-dessous : 1 2 3 4 5 6 def liste_chiffres ( n ): L = [ n % 10 ] while n > 0 : n = n // 10 L . insert ( 0 , n % 10 ) return L Malheureusement sa fonction ne retourne pas le r\u00e9sultat attendu pour l'entier 730 : 1 2 >>> liste_chiffres(730) [0, 7, 3, 0] Proposer une version corrig\u00e9e de la fonction liste_chiffres .","title":"Automatisme 6"},{"location":"section/automatismes/#automatisme-7","text":"On travaille sur des tableaux \u00e0 deux dimensions qui repr\u00e9sentent des images binaires : un pixel a pour valeur un entier : 0 pour un pixel noir et 1 pour un pixel blanc. Compl\u00e9ter les fonctions ci-dessous en respectant leurs sp\u00e9cifications, les postconditions doivent \u00eatre v\u00e9rifi\u00e9es. Lien vers Basthon pour tester en ligne . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def image_noire ( largeur , hauteur ): \"\"\" Param\u00e8tre : largeur et hauteur deux entiers non nuls Valeur renvoy\u00e9e : un tableau \u00e0 2 dimensions repr\u00e9sentant une image binaire de dimensions (largeur, hauteur) rempli de 0 \"\"\" # \u00e0 compl\u00e9ter avec un tableau en compr\u00e9hension def dimensions ( tab ): \"\"\" Param\u00e8tre : tab un tableau \u00e0 deux dimensions d'entiers repr\u00e9sentant une image binaire rectangulaire Valeur renvoy\u00e9e : un tableau de deux entiers [largeur, hauteur] repr\u00e9sentant les dimensions de l'image \"\"\" # \u00e0 compl\u00e9ter def nombre_blancs ( tab ): \"\"\" Param\u00e8tre : tab un tableau \u00e0 deux dimensions d'entiers repr\u00e9sentant une image binaire rectangulaire Valeur renvoy\u00e9e : un entier repr\u00e9sentant le nombre de pixels blancs (valeur 1) \"\"\" # \u00e0 compl\u00e9ter #postconditions pour la fonction image_noire assert image_noire ( 2 , 1 ) == [[ 0 , 0 ]] assert image_noire ( 1 , 2 ) == [[ 0 ], [ 0 ]] assert image_noire ( 3 , 2 ) == [[ 0 , 0 , 0 ], [ 0 , 0 , 0 ]] #postconditions pour la fonction dimensions assert dimensions ([[], []]) == [ 2 , 0 ] assert dimensions ([[ 0 , 1 , 2 ], [ 3 , 4 , 5 ]]) == [ 2 , 3 ] #postconditions pour la fonction nombre_blancs assert nombre_blancs ([[ 0 , 0 ], [ 0 , 0 ]]) == 0 assert dimensions ([[ 0 , 1 , 1 ], [ 0 , 1 , 0 ]]) == 3 assert dimensions ([[], []]) == 0","title":"Automatisme 7"},{"location":"section/automatismes/#automatisme-8","text":"Modifier les expressions \"\u00e0 modifier\" dans la fonction Python ci-dessous pour que la sp\u00e9cification soit v\u00e9rifi\u00e9e. Tester le code dans Basthon D\u00e9commenter #test_indice_maximum(indice_maximum) en ligne 63 pour soumettre votre fonction au test unitaire. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def indice_maximum ( tab , debut , fin ): \"\"\" Param\u00e8tres : tab un tableau d'entiers debut un entier indice du d\u00e9but de la plage fin un entier indice de la fin de la plage (inclus) Valeur renvoy\u00e9e : l'indice de la premi\u00e8re occurence du maximum de tab dans la plage de valeurs entre les indice et debut et fin (inclus) \"\"\" imax = \"\u00e0 modifier\" for i in range ( imax + 1 , fin + 1 ): if \"\u00e0 modifier\" : imax = \"\u00e0 modifier\" return imax","title":"Automatisme 8"},{"location":"section/automatismes/#automatisme-9","text":"Modifier les expressions \"\u00e0 modifier\" dans la fonction tri_selection ci-dessous pour que la sp\u00e9cification et l'assertion plac\u00e9e \u00e0 la fin de la boucle externe soient v\u00e9rifi\u00e9s. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri_selection ( tab ): \"\"\" Param\u00e8tre : tab un tableau de nombres Valeur renvoy\u00e9e : tab Postcondition : valeur renvoy\u00e9e de tab tri\u00e9e dans l'ordre croissant \"\"\" i = len ( tab ) - 1 while i >= 1 : imax = indice_maximum ( tab , \"\u00e0 modifier\" , \"\u00e0 modifier\" ) tab [ i ], tab [ imax ] = \"\u00e0 modifier\" # assertion qui doit \u00eatre v\u00e9rifi\u00e9e assert max ( tab [: i + 1 ]) == tab [ i ] i = \"\u00e0 modifier\" return tab D\u00e9commenter #test_tri(tri_selection) en ligne 64 pour soumettre votre fonction au test unitaire.","title":"Automatisme 9"},{"location":"section/automatismes/#automatisme-10","text":"Un algorithme de tri d\u2019une liste d\u2019entiers est impl\u00e9ment\u00e9 de la fa\u00e7on suivante : 1 2 3 4 5 6 7 8 9 def trier ( L ) : for i in range ( len ( L )): indice_min = i for j in range ( i + 1 , len ( L )): if L [ j ] < L [ indice_min ] : indice_min = j L [ i ], L [ indice_min ] = L [ indice_min ], L [ i ] # assertion vraie \u00e0 cet endroit return L Parmi les assertions suivantes laquelle reste vraie \u00e0 chaque it\u00e9ration de la boucle, \u00e0 l'endroit indiqu\u00e9 ci-dessus ? R\u00e9ponse A : la sous-liste L[0:i+1] contient les i plus grandes valeurs de L tri\u00e9es par ordre d\u00e9croissant R\u00e9ponse B : la sous-liste L[0:i+1] contient les i plus grandes valeurs de L tri\u00e9es par ordre croissant R\u00e9ponse C : la sous-liste L[0:i+1] contient les i plus petites valeurs de L tri\u00e9es par ordre d\u00e9croissant R\u00e9ponse D : la sous-liste L[0:i+1] contient les i plus petites valeurs de L tri\u00e9es par ordre croissant","title":"Automatisme 10"},{"location":"section/automatismes/#automatisme-11","text":"Compl\u00e9ter la fonction Python ci-dessous pour que la sp\u00e9cification et les postconditions soient satisfaites. Combient de comparaisons sont faites lors de l'appel un_doublon(list(range(100))) ? 1 2 3 4 5 6 7 8 9 10 11 12 13 def un_doublon ( t ): \"\"\" Param\u00e8tre : t un tableau de nombres Valeur renvoy\u00e9e : un bool\u00e9en True si t comporte au moins un doublon False sinon \"\"\" #\u00e0 compl\u00e9ter assert un_doublon ([ 1 , 2 , 3 ]) == False assert un_doublon ([ 1 , 2 , 2 ]) == True assert un_doublon ([ 1 , 2 , 4 , 2 ]) == True assert un_doublon ([]) == False","title":"Automatisme 11"},{"location":"section/automatismes/#automatisme-12","text":"Compl\u00e9ter la fonction Python ci-dessous pour que la sp\u00e9cification et les postconditions soient satisfaites. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def index_premiere_occurence_dicho ( x , t ): \"\"\" Param\u00e8tre : t un tableau de nombres tri\u00e9 dans l'ordre croissant x un nombre Valeur renvoy\u00e9e : l'index de la premi\u00e8re de x dans t si x est dans t -1 sinon \"\"\" a = 0 b = len ( t ) - 1 while a <= b : m = ( a + b ) // 2 if t [ m ] < x : \"\u00e0 compl\u00e9ter\" elif t [ m ] > x : \"\u00e0 compl\u00e9ter\" else : \"\u00e0 compl\u00e9ter\" return \"\u00e0 compl\u00e9ter\" return - 1 assert index_premiere_occurence_dicho ( 10 , [ 10 , 10 , 11 , 12 , 13 ]) == 1 assert index_premiere_occurence_dicho ( 10 , [ 9 , 10 , 11 , 12 , 13 ]) == 1 assert index_premiere_occurence_dicho ( 10 , [ 9 , 9 , 11 , 12 , 13 ]) == - 1 assert index_premiere_occurence_dicho ( 10 , [ 7 , 8 , 9 , 10 ]) == 3 assert index_premiere_occurence_dicho ( 10 , [ 7 , 10 , 10 , 10 , 10 ]) == 1 assert index_premiere_occurence_dicho ( 10 , []) == - 1","title":"Automatisme 12"},{"location":"section/automatismes/#automatisme-13","text":"Compl\u00e9ter la fonction Python ci-dessous pour que la sp\u00e9cification et les postconditions soient satisfaites. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def est_decroissant ( t ): \"\"\" Param\u00e8tre : t un tableau de nombres Valeur renvoy\u00e9e : bool\u00e9en indiquant si t dans l'ordre d\u00e9croissant \"\"\" \"\u00e0 compl\u00e9ter\" def recherche_dicho_decroissant ( x , t ): \"\"\" Param\u00e8tre : t un tableau de nombres tri\u00e9 dans l'ordre d\u00e9croissant x un nombre Valeur renvoy\u00e9e : index de x dans t si x dans t None si x pas dans t \"\"\" a = 0 b = len ( t ) - 1 while a <= b : m = ( a + b ) // 2 \"\u00e0 compl\u00e9ter\" return None assert est_decroissant ([ k ** 2 for k in range ( 10 )]) == False assert est_decroissant ([]) == True t1 = list ( range ( 10 , - 1 , - 1 )) assert est_decroissant ( t1 ) == True assert recherche_dicho_decroissant ( 8 , t1 ) == 2 assert recherche_dicho_decroissant ( 10 , t1 ) == 0 assert recherche_dicho_decroissant ( 0 , t1 ) == 10 assert recherche_dicho_decroissant ( 4.5 , t1 ) == None print ( \"Test unitaires r\u00e9ussis pour l'automatisme 13 : recherche_dicho_decroissant et est_decroissant\" )","title":"Automatisme 13"},{"location":"section/automatismes/#automatisme-14","text":"Convertir en flottant au format simple pr\u00e9cision (mantisse sur 8 bits et exposant sur 23 bits), le nombre d'\u00e9criture d\u00e9cimale 9,78125. Convertir en flottant au format simple pr\u00e9cision (mantisse sur 8 bits et exposant sur 23 bits), le nombre d'\u00e9criture d\u00e9cimale 0,1. V\u00e9rifier avec le convertisseur en ligne https://www.h-schmidt.net/FloatConverter/IEEE754.html ou la fonction donn\u00e9e ci-dessous : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def decimal_vers_IEE754 ( x , taille_exposant , taille_mantisse ): #print(\"d\u00e9termination du signe\") if x > 0 : print ( \"Bit de signe : 0\" ) elif x < 0 : print ( \"Bit de signe : 1\" ) else : print ( \"O valeur particuli\u00e8re\" ) if x != 0 : #print(\"d\u00e9termination de l'exposant\") exposant = 0 while int ( x ) >= 1 : x = x / 2 exposant = exposant + 1 while int ( x ) == 0 : x = x * 2 exposant = exposant - 1 decalage = 2 ** ( taille_exposant - 1 ) - 1 print ( \"Exposant en d\u00e9cimal : \" , exposant ) print ( f \"Exposant d\u00e9cal\u00e9 de + { decalage } : \" , exposant + decalage ) print ( f \"Exposant d\u00e9cal\u00e9 de + { decalage } : codage binaire sur 11 bits : \" , bin ( exposant + decalage ) . lstrip ( '0b' ) . zfill ( taille_exposant )) #print(\"d\u00e9termination des bits de mantisse\") x = x - 1 nbits = 0 mantisse = [] while nbits < taille_mantisse : x = x * 2 partie_entiere = int ( x ) mantisse . append ( str ( partie_entiere )) if partie_entiere == 1 : x = x - partie_entiere nbits = nbits + 1 print ( \"Mantisse : \" , '' . join ( mantisse ))","title":"Automatisme 14"},{"location":"section/automatismes/#automatisme-15","text":"On consid\u00e8re une formule bool\u00e9enne form des variables bool\u00e9ennes a et b dont voici la table de v\u00e9rit\u00e9. a b form True True False False True True True False True False False False Quelle est cette formule bool\u00e9enne ? R\u00e9ponse A : a and b R\u00e9ponse B : a or b R\u00e9ponse C : ((not(a)) and b) or (a and (not(b))) R\u00e9ponse D : (not(a)) or (not(b))","title":"Automatisme 15"},{"location":"section/automatismes/#automatisme-16","text":"Pouvez-vous deviner ce qui va se passer si on ex\u00e9cute le code ci-dessous ? V\u00e9rifiez. Explication ? def boucle1(): x = 1 h = 1 c = 0 while x < 2: h = h / 2 x = x + h c = c + 1 return x == 2, c boucle1() R\u00e9ponse A : (False, 53) R\u00e9ponse B : (True, 53) R\u00e9ponse C : (True, 52) R\u00e9ponse D : la boucle ne se termine pas car d'apr\u00e8s une formule du cours de math\u00e9matiques sur la somme des termes cons\u00e9cutifs d'une suite g\u00e9om\u00e9trique, pour tout entier naturel n on a : <a href=\"https://www.codecogs.com/eqnedit.php?latex=1+1/2+1/2 2+...+1/2 n&space;=&space;(1-1/2 {n+1})/(1-1/2)=2(1-1/2 )<2\" target=\"_blank\"><img src=\"https://latex.codecogs.com/gif.latex?1+1/2+1/2 2+...+1/2 n&space;=&space;(1-1/2 {n+1})/(1-1/2)=2(1-1/2 )<2\" title=\"1+1/2+1/2 2+...+1/2 n = (1-1/2 {n+1})/(1-1/2)=2(1-1/2 )<2\" />","title":"Automatisme 16"},{"location":"section/automatismes/#automatisme-17-banque-depreuve-pratique-2021","text":"\u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : 1 2 3 4 5 6 7 8 >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3","title":"Automatisme 17 (banque d'\u00e9preuve pratique 2021)"},{"location":"section/automatismes/#automatisme-18-banque-depreuve-pratique-2021","text":"\u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : 1 2 >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 )","title":"Automatisme 18 (banque d'\u00e9preuve pratique 2021)"},{"location":"section/automatismes/#automatisme-19-banque-depreuve-pratique-2021","text":"On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. Compl\u00e9ter la fonction insere ci-dessous. def insere(a, tab): l = list(tab) #l contient les m\u00eames \u00e9l\u00e9ments que tab l.append(a) i = \"\u00e0 compl\u00e9ter\" while i >= 0 and a < \"\u00e0 compl\u00e9ter\" : l[i+1] = \"\u00e0 compl\u00e9ter\" l[i] = a i = \"\u00e0 compl\u00e9ter\" return l assert insere(3,[1,2,4,5]) == [1, 2, 3, 4, 5] assert insere(10,[1,2,7,12,14,25]) == [1, 2, 7, 10, 12, 14, 25] assert insere(1,[2,3,4]) == [1,2,3,4] print('Tests r\u00e9ussis')","title":"Automatisme 19 (banque d'\u00e9preuve pratique 2021)"},{"location":"section/automatismes/#automatisme-20-banque-depreuve-pratique-2021","text":"Compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. def dichotomie(tab, x): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len(tab) - 1 while debut < = fin: m = \"\u00e0 compl\u00e9ter\" if x == tab[m]: return \"\u00e0 compl\u00e9ter\" if x > tab[m]: debut = m + 1 else: fin = \"\u00e0 compl\u00e9ter\" return \"\u00e0 compl\u00e9ter\" assert dichotomie([15, 16, 18, 19, 23, 24, 28, 29, 31, 33],28) == True assert dichotomie([15, 16, 18, 19, 23, 24, 28, 29, 31, 33],27) == False print('Tests r\u00e9ussis')","title":"Automatisme 20 (banque d'\u00e9preuve pratique 2021)"},{"location":"section/automatismes/#automatisme-21-banque-depreuve-pratique-2021","text":"\u00c9crire une fonction tri_selection qui prend en param\u00e8tre un tableau tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9 dans l'ordre croissant. Exemples de postconditions : 1 2 3 4 >>> assert tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) == [ - 9 , 1 , 6 , 12 , 52 ] >>> assert tri_selection ([]) == [] >>> assert tri_selection ([ 1 , 4 , 8 ]) == [ 1 , 4 , 8 ] >>> assert tri_selection ([ 8 , 4 , 1 ]) == [ 1 , 4 , 8 ]","title":"Automatisme 21 (banque d'\u00e9preuve pratique 2021)"},{"location":"section/automatismes/#automatisme-22-banque-depreuve-pratique-2021","text":"Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob, radar, et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s'appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. def inverse_chaine(chaine): result = \"\u00e0 compl\u00e9ter\" for caractere in chaine: result = \"\u00e0 compl\u00e9ter\" return result def est_palindrome(chaine): inverse = inverse_chaine(chaine) return \"\u00e0 compl\u00e9ter\" def est_nbre_palindrome(nbre): chaine = \"\u00e0 compl\u00e9ter\" return est_palindrome(chaine) assert inverse_chaine('bac') == 'cab' assert est_palindrome('NSI') == False assert est_palindrome('ISN-NSI') == True assert est_nbre_palindrome(214312) == False assert est_nbre_palindrome(213312) == True print(\"Tests r\u00e9ussis\")","title":"Automatisme 22 (banque d'\u00e9preuve pratique 2021)"},{"location":"section/automatismes/#automatisme-23-banque-depreuve-pratique-2021","text":"Compl\u00e9ter la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. def separe(tab): i = 0 j = \"\u00e0 compl\u00e9ter\" while i < j : if tab[i] == 0 : i = \"\u00e0 compl\u00e9ter\" else : tab[i], tab[j] = \"\u00e0 compl\u00e9ter\" j = \"\u00e0 compl\u00e9ter\" return tab assert separe([1, 0, 1, 0, 1, 0, 1, 0]) == [0, 0, 0, 0, 1, 1, 1, 1] assert separe([1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0]) == [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1] print(\"Tests r\u00e9ussis\")","title":"Automatisme 23 (banque d'\u00e9preuve pratique 2021)"},{"location":"section/automatismes/#automatisme-24-banque-depreuve-pratique-2021","text":"\u00c9crire une fonction indice_du_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : 1 2 3 4 5 6 >>> indice_du_min ([ 5 ]) 0 >>> indice_du_min ([ 2 , 4 , 1 ]) 2 >>> indice_du_min ([ 5 , 3 , 2 , 2 , 4 ]) 2","title":"Automatisme 24 (banque d'\u00e9preuve pratique 2021)"},{"location":"section/automatismes/#automatisme-25-traitement-de-donnees-en-tables","text":"T\u00e9l\u00e9charger l'archive avec le code source \u00e0 compl\u00e9ter et le fichier eleves.csv . Un corrig\u00e9 est ici . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 #!/usr/bin/env python \"\"\"Consigne : compl\u00e9ter au niveau des \u00e0 \"compl\u00e9ter\" les fonctions : 1) moyenne_table 2) enreg_avec_recompense 3) generer_table_recompenses 4) decompte_recompenses 5) clef_tri_moyenne_decroissant 6) clef_tri_alphabetique_croissant_moyenne_decroissant Chaque fonction est accompagn\u00e9 d'un test unitaire => pour tester, d\u00e9sactiver les commentaires dans le programme principal \u00e0 partir de la ligne 151 Pour les tris il faut aussi compl\u00e9ter le programme principal en lignes 167 et 171 \"\"\" import csv #Import / Export d'un tel fichier CSV ver la repr\u00e9sentation d'une tble en Python (tableau de dictionnaires) def lecture_csv ( fichier , delimiteur ): \"\"\" Param\u00e8tre : un chemin vers un fichier CSV Valeur renvoy\u00e9e : un tableau de dictionnaires, extraction de la table contenue dans le fichier \"\"\" f = open ( fichier , mode = 'r' , encoding = 'utf8' , newline = '' ) reader = csv . DictReader ( f , delimiter = delimiteur ) #cr\u00e9ation de l'objet reader table = [ dict ( enregistrement ) for enregistrement in reader ] f . close () return table def ecriture_csv ( table , fichier , delimiteur ): \"\"\" Param\u00e8tre : un chemin vers un fichier CSV une table comme tableau de dictionnaires partageant les m\u00eames clefs, de valeurs str Valeur renvoy\u00e9e : None, \u00e9crit table dans fichier avec Dictriter du module CSV \"\"\" g = open ( fichier , mode = 'w' , encoding = 'utf8' , newline = '' ) attributs = list ( table [ 0 ] . keys ()) writer = csv . DictWriter ( g , delimiter = delimiteur , fieldnames = attributs ) #cr\u00e9ation de l'objet writer writer . writeheader () #\u00e9criture des attibuts for enregistrement in table : writer . writerow ( enregistrement ) #\u00e9criture des enregistrements g . close () def moyenne_table ( table_eleves ) : \"\"\"Param\u00e8tre : table_eleves est une repr\u00e9sentation de la table extraite de eleves.csv sous forme de tableau de dictionnaires. Attention les attributs 'moyenne' sont de type 'str' Valeur renvoy\u00e9e : un flottant repr\u00e9sentant la moyenne de tous les \u00e9l\u00e8ves de la table arrondie \u00e0 2 chiffres apr\u00e8s la virgule \"\"\" somme = 0 compteur = 0 for enreg in table_eleves : \"\u00e0 compl\u00e9ter\" \"\u00e0 compl\u00e9ter\" return round ( somme / compteur , 2 ) def test_moyenne_table (): assert moyenne_table ( table_eleves ) == 11.46 print ( \"Test unitaire de moyenne_table r\u00e9ussi\" ) def enreg_avec_recompense ( enreg ): \"\"\" Param\u00e8tre : enreg un dictionnaire de clefs 'pr\u00e9nom', 'nom', 'moyenne' Attention toutes les clefs ont des valeurs de type str Valeur renvoy\u00e9e : extension du dictionnaire avec une nouvelle clef 'r\u00e9compense' de valeurs s : 'insuffisant' si moyenne < 8 'm\u00e9diocre' si 8 <= moyenne < 10 'passable' si 10 <= moyenne < 12 'encouragements' si 12 <= moyenne < 14 'compliments' si 14 <= moyenne < 16 'f\u00e9licitations' si moyenne > 16 \"\"\" copie = { clef : valeur for clef , valeur in enreg . items () } m = \"\u00e0 compl\u00e9ter\" if m < 8 : copie [ 'r\u00e9compense' ] = 'insuffisant' elif \"\u00e0 compl\u00e9ter\" : copie [ 'r\u00e9compense' ] = 'm\u00e9diocre' elif \"\u00e0 compl\u00e9ter\" : copie [ 'r\u00e9compense' ] = 'passable' elif \"\u00e0 compl\u00e9ter\" : copie [ 'r\u00e9compense' ] = 'encouragements' elif \"\u00e0 compl\u00e9ter\" : copie [ 'r\u00e9compense' ] = 'compliments' else : copie [ 'r\u00e9compense' ] = 'f\u00e9licitations' return copie def generer_table_recompenses ( table_eleves ): \"\"\"Param\u00e8tre : table_eleves est une repr\u00e9sentation de la table extraite de eleves.csv sous forme de tableau de dictionnaires Valeur renvoy\u00e9e : une extension de table_eleves avec un nouvel attribut 'r\u00e9compense' chaque nouvel enregistrement est g\u00e9n\u00e9r\u00e9 par enreg_avec_recompense \"\"\" table_recompenses = \"\u00e0 compl\u00e9ter\" return table_recompenses def test_generer_table_recompenses (): \"\"\"Test unitaires de generer_table_recompenses\"\"\" table_recompenses = generer_table_recompenses ( table_eleves ) assert table_recompenses [ 0 ] == { 'pr\u00e9nom' : 'Zo\u00e9' , 'nom' : 'Collin' , 'moyenne' : '19' , 'r\u00e9compense' : 'f\u00e9licitations' } assert table_recompenses [ 8 ] == { 'pr\u00e9nom' : 'Roland' , 'nom' : 'Joly' , 'moyenne' : '8' , 'r\u00e9compense' : 'm\u00e9diocre' } print ( \"Test unitaires de generer_table_recompenses r\u00e9ussis\" ) def decompte_recompenses ( table_recompenses ): \"\"\"Param\u00e8tre : table_recompenses est une repr\u00e9sentation de la table renvoy\u00e9e par generer_table_recompenses. Valeur renvoy\u00e9e : un dictionnaire avec le d\u00e9compte de chaque r\u00e9compense \"\"\" decompte = dict () for enreg in table_recompenses : \"\u00e0 compl\u00e9ter\" \"\u00e0 compl\u00e9ter\" \"\u00e0 compl\u00e9ter\" \"\u00e0 compl\u00e9ter\" return decompte def test_decompte_recompenses (): \"\"\"Test unitaires de decompte_recompenses\"\"\" decompte = decompte_recompenses ( table_recompenses ) assert decompte == { 'f\u00e9licitations' : 89 , 'm\u00e9diocre' : 77 , 'compliments' : 95 , 'insuffisant' : 86 , 'passable' : 81 , 'encouragements' : 72 } print ( \"Test unitaires de decompte_recompenses r\u00e9ussis\" ) def clef_tri_moyenne_decroissant ( enreg ): \"\"\"Clef de tri par moyenne d\u00e9croissante Attention la valeur de l'attribut 'moyenne' de enreg est de type str\"\"\" return \"\u00e0 compl\u00e9ter\" def clef_tri_alphabetique_croissant_moyenne_decroissant ( enreg ): \"\"\"Clef de tri par moyenne d\u00e9croissante Attention la valeur de l'attribut 'moyenne' de enreg est de type str\"\"\" return \"\u00e0 compl\u00e9ter\" #Programme principal table_eleves = lecture_csv ( 'eleves.csv' , ',' ) #D\u00e9commenter lorsque moyenne_table est compl\u00e9t\u00e9e #test_moyenne_table() #D\u00e9commenter lorsque generer_table_recompenses est compl\u00e9t\u00e9e #table_recompenses = generer_table_recompenses(table_eleves) #test_generer_table_recompenses() #D\u00e9commenter lorsque decompte_recompenses est compl\u00e9t\u00e9e #test_decompte_recompenses() #D\u00e9commenter e lorsque clef_tri_moyenne_decroissant termin\u00e9e #table_recompenses = generer_table_recompenses(table_eleves) #Ecrire une instruction qui permet de trier table_recompenses dans l'ordre d\u00e9croissant des moyennes #table_tri1 = \"\u00e0 compl\u00e9ter\" #Ecrire une instruction qui permet de trier table_recompenses : #d'abord dans l'ordre alphab\u00e9tique croissant puis dans l'ordre d\u00e9croissant des moyennes #table_tri2 = \"\u00e0 compl\u00e9ter\"","title":"Automatisme 25 : traitement de donn\u00e9es en tables"},{"location":"section/cours-tables-indexation-git/","text":"Cr\u00e9dits Table de donn\u00e9es \u00c9change de table de donn\u00e9es avec un fichier CSV Manipulation de fichiers CSV en Python Synth\u00e8se Cr\u00e9dits \u2693\ufe0e Ce cours est largement inspir\u00e9 de deux sources : le chapitre 15 du manuel NSI de la collection Tortue chez Ellipse, auteurs : Ballabonski, Conchon, Filliatre, N\u2019Guyen ; le cours de Julien de Vill\u00e8le . Table de donn\u00e9es \u2693\ufe0e Histoire 1 L'homme organisait les donn\u00e9es sous forme de tableau bien avant l'invention de l'ordinateur : les donn\u00e9es tabulaires ou tables de donn\u00e9es , apparaissent d\u00e9j\u00e0 dans les livres de compte de l'\u00c9gypte ancienne. De nos jours les relev\u00e9s de comptes bancaires sont encore pr\u00e9sent\u00e9s sous forme de tableaux avec pour chaque op\u00e9ration sa date, sa nature (d\u00e9bit ou cr\u00e9dit) et son montant. En informatique, les tables de donn\u00e9es se sont d\u00e9velopp\u00e9es dans dans les ann\u00e9es 1970 avec l'essor des Syst\u00e8mes de Gestion de Base de Donn\u00e9es s'appuyant sur le mod\u00e8le relationnel propos\u00e9 par Edgar F. Codd chez IBM. Les Syst\u00e8mes de Gestion de Base de Donn\u00e9es permettent aujourd'hui le traitement automatique de gigantesques bases de donn\u00e9es, qui est un \u00e9l\u00e9ment fondamental dans nos soci\u00e9t\u00e9s de l'information. Les Syst\u00e8mes de Gestion de Base de Donn\u00e9es seront \u00e9tudi\u00e9s en classe de terminale. Nous pr\u00e9senterons cette ann\u00e9e les traitements de tables de donn\u00e9es qui peuvent \u00eatre effectu\u00e9s \u00e0 l'aide de scripts Python, ce qui couvre d\u00e9j\u00e0 un large champ de besoins en data science , bio-informatique , informatique financi\u00e8re ou de gestion ... D\u00e9finition 1 Une feuille de tableur est un mod\u00e8le de donn\u00e9es tabulaires ou table de donn\u00e9es . D\u00e9finissons le vocabulaire : Une table , repr\u00e9sent\u00e9e sous forme de tableau, est une collection d'\u00e9l\u00e9ments qui sont les lignes du tableau. Chaque \u00e9l\u00e9ment de la table , ou ligne de sa repr\u00e9sentation sous forme de tableau, s'appelle un enregistrement . Tous les enregistrements d'une m\u00eame table sont des p-uplets nomm\u00e9s qui partagent les m\u00eames descripteurs , appel\u00e9s aussi attributs . Dans une repr\u00e9sentation de la table sous forme de tableau, chaque attribut correspond \u00e0 une colonne. Chaque attribut est caract\u00e9ris\u00e9 par son type et son domaine de valeurs . Dans une repr\u00e9sentation sous forme de tableau, les descripteurs ou attributs sont en g\u00e9n\u00e9ral plac\u00e9s comme en-t\u00eate de colonnes sur la premi\u00e8re ligne. Example 1 La table repr\u00e9sent\u00e9e ci-dessus rassemble les enregistrements des clients d'un site web marchand. Les attributs de cette table sont : le nom et le pr\u00e9nom du client de type cha\u00eene de caract\u00e8res l'adresse mail du client du type cha\u00eene de caract\u00e8res avec un domaine de valeurs particulier le d\u00e9partement du client du type cha\u00eene de caract\u00e8res avec un domaine de valeurs particulier le nombre de visites du client de type entier avec pour domaine de valeurs les entiers positifs les d\u00e9penses du client de type flottant avec pour domaine de valeurs les flottants positifs \u00c9change de table de donn\u00e9es avec un fichier CSV \u2693\ufe0e Point de cours1 Pour \u00e9changer des donn\u00e9es tabulaires entre les programmes qui doivent les manipuler, on les exporte puis les importe sous la forme de fichiers textes, c'est-\u00e0-dire lisibles par l'\u00eatre humain. Afin d'assurer l'interop\u00e9rabilit\u00e9 entre diff\u00e9rents programmes, un fichier doit respecter un format normalis\u00e9. L'un des formats les plus r\u00e9pandus pour l'\u00e9change de donn\u00e9es tabulaires est le format CSV pour Comma Separated Values : un fichier CSV est un fichier texte donc \u00e9ditable avec un \u00e9diteur de textes comme Notepad++ ; chaque ligne du fichier correspond \u00e0 un enregistrement de la table pour un enregistrement donn\u00e9, les valeurs des diff\u00e9rents attributs sont s\u00e9par\u00e9es en champs par un d\u00e9limiteur qui est en g\u00e9n\u00e9ral l'un des symboles , ou ; ou : . la premi\u00e8re ligne contient en g\u00e9n\u00e9ral les noms des attributs . les champs peuvent \u00eatre d\u00e9limit\u00e9s par des guillemets droits \" s'ils contiennent du texte avec des espaces ou des sauts de ligne. Le caract\u00e8re \" est alors \u00e9chapp\u00e9 en \"\" pour le distinguer des guillemets droits d\u00e9limiteurs. Voici un extrait d'un fichier CSV correspondant \u00e0 la table pr\u00e9sent\u00e9e dans l'exemple 1 : 1 2 3 4 5 nom,pr\u00e9nom,email,d\u00e9partement,naissance,visites,d\u00e9penses Gomes,Brigitte,bgomes@laposte.net,79,1960-08-21,67,8342.99 Nicolas,Georges,gnicolas@yahoo.fr,10,1994-05-26,86,10908.08 Berger,P\u00e9n\u00e9lope,pberger@noos.fr,73,2001-03-01,131,3817.79 Charrier,Richard,rcharrier@sfr.fr,2B,1977-08-07,16,997.09 On donne ci-dessous un autre extrait de fichier CSV qui est un export de fichier d'identifiants de l'Espace Num\u00e9rique de Travail (avec valeurs modifi\u00e9es). La table comporte 19 attributs de rne \u00e0 pays list\u00e9s sur la premi\u00e8re ligne. Le premier enregistrement figure sur la deuxi\u00e8me ligne avec pour valeur du premier champ 0690026D et sept champs vides \u00e0 la fin. On observe que le d\u00e9limiteur de champ est le symbole ; , que les champs peuvent contenir des espaces, que certains sont vides et que le nombre de champs pour le premier enregistrement ne correspond pas au nombre d'attributs ! On peut imaginer que pour traiter un tel fichier avec un programme, il faut d'abord analyser sa structure, ses particularit\u00e9s et pr\u00e9voir d'\u00e9ventuelles irr\u00e9gularit\u00e9s dans les donn\u00e9es (absence, erreurs de type, de saisie, corruption du fichier ...). Le contr\u00f4le de la validit\u00e9 des donn\u00e9es doit donc \u00eatre une composante du programme de traitement. 1 2 rne;uid;classe;profil;prenom;nom;login;mot de passe;cle de jointure;uid pere;uid mere;uid tuteur1;uid tuteur2;prenom enfant;nom enfant;adresse;code postal;ville;pays 0690026D;WKZ08710;813;Eleve;Mathieu;DUPONT;mathieu.dupont;>>>> Mot de passe d\u00e9j\u00e0 modifi\u00e9 par utilisateur >>>>;AC-LYON$3780909;WKZ02158;WKZ02171;;;;;;;; Exercice 1 Questions type E3C Dans la plupart des fichiers CSV, que contient la premi\u00e8re ligne ? R\u00e9ponse A : des notes concernant la table de donn\u00e9es R\u00e9ponse B : les sources des donn\u00e9es R\u00e9ponse C : les descripteurs des champs de la table de donn\u00e9es R\u00e9ponse D : l'auteur de la table de donn\u00e9es Laquelle de ces affirmations est vraie ? R\u00e9ponse A : on ne peut acc\u00e9der au contenu d'un fichier CSV que par l'interm\u00e9diaire d'un programme Python R\u00e9ponse B : CSV est un format de chiffrement des donn\u00e9es R\u00e9ponse C : le format CSV a \u00e9t\u00e9 con\u00e7u pour assurer la confidentialit\u00e9 d'une partie du code d'un programme R\u00e9ponse D : les fichiers CSV sont compos\u00e9s de donn\u00e9es s\u00e9par\u00e9es par des caract\u00e8res comme des virgules Qu'est-ce que le format de fichier CSV ? R\u00e9ponse A : un format de fichier mis au point par Microsoft pour Excel R\u00e9ponse B : un format de fichier pour d\u00e9crire une base de donn\u00e9e R\u00e9ponse C : un format de fichier o\u00f9 les donn\u00e9es sont s\u00e9par\u00e9es par un caract\u00e8re tel qu'une virgule R\u00e9ponse D : un format de fichier d\u00e9crivant une page Web Manipulation de fichiers CSV en Python \u2693\ufe0e D\u00e9finition 2 L'indexation de table est la cr\u00e9ation d'une structure de donn\u00e9es \u00e0 partir de donn\u00e9es tabulaires. Nous allons pr\u00e9senter quelques m\u00e9thodes d'indexation de table extraite d'un fichier CSV vers une structure de donn\u00e9es du langage Python : tableau de tableaux ou tableau de dictionnaires que nous privil\u00e9gierons. Dans cette section, on consid\u00e8re le fichier CSV , clients_mini.csv , repr\u00e9sentant un extrait de la table de l\u2019exemple 1 avec les enregistrements de 20 clients d\u2019un site web marchand. M\u00e9thode 1 Pr\u00e9sentons deux m\u00e9thodes de lecture de fichiers CSV qui utilisent les outils standards de Python. On fait les hypoth\u00e8ses suivantes : la premi\u00e8re ligne du fichier contient les attributs et on conna\u00eet le d\u00e9limiteur, ici le symbole , . Lecture On peut extraire les attributs et la table contenus dans le fichier clients_mini.csv avec le code ci-dessous : 1 2 3 4 fichier = open ( 'clients_mini.csv' , encoding = 'utf8' , newline = '' ) #ouverture du fichier attributs = fichier . readline () . rstrip () . split ( ',' ) #extraction de la ligne des attributs table = [ ligne . rstrip () . split ( ',' ) for ligne in fichier ] #extraction des autres lignes fichier . close () #fermeture du fichier La m\u00e9thode open permet de cr\u00e9er un objet fichier qu'on peut parcourir ligne par ligne avec un curseur : d'abord la premi\u00e8re ligne avec fichier.readline() puis les lignes suivantes en it\u00e9rant sur fichier . Il est important de pr\u00e9ciser l'encodage du fichier , par d\u00e9faut c'est celui du syst\u00e8me d'exploitation. Chaque ligne est une cha\u00eene de caract\u00e8res d\u00e9coup\u00e9e en liste de champs selon le d\u00e9limiteur pass\u00e9 en param\u00e8tre \u00e0 la m\u00e9thode split . Le caract\u00e8re de saut de lignes a d'abord \u00e9t\u00e9 supprim\u00e9 avec la m\u00e9thode rstrip . On r\u00e9cup\u00e8re ainsi les attributs comme un tableau de type list et la table comme un tableau d'enregistrements qui sont eux-m\u00eames des tableaux. Notons que toutes les valeurs sont des cha\u00eenes de caract\u00e8res et qu'il faudra convertir certaines pour les traiter ! 1 2 3 4 5 6 >>> attributs #tableau des attributs [ 'nom' , 'pr\u00e9nom' , 'email' , 'd\u00e9partement' , 'naissance' , 'visites' , 'd\u00e9penses' ] >>> table [ 0 ] #tableau premier enregistrement [ 'Gomes' , 'Brigitte' , 'bgomes@laposte.net' , '79' , '1960-08-21' , '67' , '8342.99' ] >>> table [: 2 ] #tableau de tableaux : extrait [[ 'Gomes' , 'Brigitte' , 'bgomes@laposte.net' , '79' , '1960-08-21' , '67' , '8342.99' ], [ 'Nicolas' , 'Georges' , 'gnicolas@yahoo.fr' , '10' , '1994-05-26' , '86' , '10908.08' ]] \u00c9criture On peut ensuite recopier les attributs et la table dans un autre fichier clients_mini_copie.csv avec le code ci-dessous : 1 2 3 4 5 6 g = open ( 'clients_mini_copie.csv' , encoding = 'utf8' , newline = '' ) premiere_ligne = ',' . join ( attributs ) + ' \\n ' g . write ( premiere_ligne ) for enregistrement in table : g . write ( ',' . join ( enregistrement ) + ' \\n ' ) g . close () La m\u00e9thode join permet de concat\u00e9ner les \u00e9l\u00e9ments d'un tableau de cha\u00eenes de caract\u00e8res avec un d\u00e9limiteur. Avec ces m\u00e9thodes, une table est donc repr\u00e9sent\u00e9e par un tableau de tableaux . On acc\u00e8de \u00e0 un enregistrement par son index dans la table et \u00e0 la valeur d'un attribut par son index dans le tableau des attributs (s\u00e9par\u00e9 de la table). C'est incommode et le code produit est peu lisible. Ainsi, pour acc\u00e9der \u00e0 l'adresse mail du premier enregistrement il faut saisir table[0][2] . On aimerait \u00e9crire table[0]['email'] . Pour cela, chaque enregistrement devrait \u00eatre un dictionnaire avec pour clefs les attributs de la table. C'est possible en utilisant le module csv . M\u00e9thode 2 Le module csv est disponible dans la biblioth\u00e8que standard et peut donc \u00eatre utilis\u00e9 sans installation sp\u00e9cifique. \u00c0 partir de la table contenu dans le m\u00eame fichier CSV 'clients_mini.csv' , ce module permet de cr\u00e9er une structure de donn\u00e9es d'un acc\u00e8s plus facile. Lecture Le code ci-dessous permet d'extraire directement la table d'un fichier CSV dans une structure de donn\u00e9es qui est un tableau de dictionnaires : chaque enregistrement est un dictionnaire dont les clefs sont les attributs list\u00e9s sur la premi\u00e8re ligne du fichier. Pour les versions de Python 3.6 et 3.7 uniquement, les dictionnaires renvoy\u00e9s sont sp\u00e9cifiques, de type OrderedDict , et on prendra soin de les convertir en dictionnaires standard avec dict . 1 2 3 4 5 6 import csv # import du module f = open ( 'clients_mini.csv' , mode = 'r' , encoding = 'utf8' , newline = '' ) reader = csv . DictReader ( f , delimiter = ',' ) #cr\u00e9ation d'un objet reader table = [ dict ( enregistrement ) for enregistrement in reader ] f . close () La structure de donn\u00e9es repr\u00e9sentant la table est un tableau de dictionnaires : l'acc\u00e8s aux enregistrements se fait par index et \u00e0 leurs attributs par clef : tr\u00e8s efficace (co\u00fbt constant) et code lisible. Notons que toutes les valeurs restent des cha\u00eenes de caract\u00e8res et qu'il faudra convertir certaines pour les traiter ! 1 2 3 4 5 6 7 8 >>> table [ 0 ] #premier enregistrement de type dictionnaire { 'nom' : 'Gomes' , 'pr\u00e9nom' : 'Brigitte' , 'email' : 'bgomes@laposte.net' , 'd\u00e9partement' : '79' , 'naissance' : '1960-08-21' , 'visites' : '67' , 'd\u00e9penses' : '8342.99' } >>> table [: 2 ] # tableu de dictionnaires : extrait [{ 'nom' : 'Gomes' , 'pr\u00e9nom' : 'Brigitte' , 'email' : 'bgomes@laposte.net' , 'd\u00e9partement' : '79' , 'naissance' : '1960-08-21' , 'visites' : '67' , 'd\u00e9penses' : '8342.99' }, { 'nom' : 'Nicolas' , 'pr\u00e9nom' : 'Georges' , 'email' : 'gnicolas@yahoo.fr' , 'd\u00e9partement' : '10' , 'naissance' : '1994-05-26' , 'visites' : '86' , 'd\u00e9penses' : '10908.08' }] >>> len ( table ) 20 >>> table [ 0 ][ 'email' ] #acc\u00e8s facile aux valeurs des attibuts par clefs 'bgomes@laposte.net' \u00c9criture L'\u00e9criture d'un tableau de dictionnaires partageant les m\u00eames clefs sous forme de table dans un fichier CSV, s'effectue de fa\u00e7on sym\u00e9trique \u00e0 travers un objet DictWriter . \u00c0 titre, d'exemple, on recopie la table extraite pr\u00e9c\u00e9demment dans un autre fichier CSV. Depuis Python 3.7, le parcours des clefs d'un dictionnaire est garanti dans le m\u00eame ordre que celui d'insertion donc on peut r\u00e9cup\u00e9rer la liste des attributs avec list(table[0].keys()) 1 2 3 4 5 6 7 g = open ( 'clients_mini_copie2.csv' , mode = 'w' , encoding = 'utf8' , newline = '' ) attributs = list ( table [ 0 ] . keys ()) writer = csv . DictWriter ( g , delimiter = ',' , fieldnames = attributs ) #cr\u00e9ation de l'objet writer writer . writeheader () #\u00e9criture des attributs for enregistrement in table : writer . writerow ( enregistrement ) #\u00e9criture des enregistrements g . close () Remarque Le module csv permet aussi d'extraire une table d'un fichier CSV sous forme de tableau de tableaux comme dans la m\u00e9thode pr\u00e9c\u00e9dente. Le d\u00e9coupage des lignes/enregistrements selon le d\u00e9limiteur est int\u00e9gr\u00e9 ce qui simplifie le code. 1 2 3 4 f = open ( 'clients_mini.csv' , mode = 'r' , encoding = 'utf8' , newline = '' ) reader = csv . reader ( f , delimiter = ',' ) table = [ ligne for ligne in reader ] f . close () Exercice 2 Le fichier clients_avec_erreurs.csv contient une table de la m\u00eame structure que celle de l'exemple 1 mais avec des donn\u00e9es invalides : pour l'attribut 'email' : format incorrect ou adresse manquante pour l'attribut 'd\u00e9partement' : valeur incorrecte pour l'attribut 'naissance' : ann\u00e9e hors post\u00e9rieure \u00e0 2005 (pas de clients de moins de 15 ans !), mois hors de la plage [1,12], jour hors de la plage possible pour l'ann\u00e9e et le mois fix\u00e9. pour les attributs : 'visites' et ' d\u00e9penses ' : valeurs n\u00e9gatives L'objectif de cet exercice est d'extraire la table du fichier, de filtrer les enregistrements valides et de les recopier dans un fichier 'clients_sans_erreurs.csv' . Ouvrir le fichier cours_exercices_tables_eleve.py dans un IDE Python. Compl\u00e9ter les fonctions de lecture / \u00e9criture d'une table repr\u00e9sent\u00e9e par un tableau de dictionnaires vers un fichier CSV : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def lecture_csv ( fichier , delimiteur ): f = open ( fichier , mode = 'r' , encoding = 'utf8' , newline = '' ) reader = csv . DictReader ( f , delimiter = delimiteur ) f . close () return table def ecriture_csv ( table , fichier , delimiteur ): g = open ( fichier , mode = 'w' , encoding = 'utf8' , newline = '' ) attributs = list ( table [ 0 ] . keys ()) writer = csv . DictWriter ( g , delimiter = delimiteur , fieldnames = attributs ) g . close () Compl\u00e9ter les fonctions bissextile , valide_mois , valide_jour puis la fonction valide_naissance . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def bissextile ( a ): \"\"\"Param\u00e8tre : a de type int repr\u00e9sentant une ann\u00e9e Valeur renvoy\u00e9e : bool\u00e9en indiquant si l'ann\u00e9e est bissextile\"\"\" return ..... def valide_annee ( j ): return 1900 <= j <= 2005 def valide_mois ( m ): \"\"\"Param\u00e8tre : m de type int repr\u00e9sentant un mois Valeur renvoy\u00e9e : bool\u00e9en indiquant si le mois est valide (entre 1 et 12)\"\"\" return .... def valide_jour ( a , m , j ): \"\"\"Param\u00e8tre : a, m, j de type int repr\u00e9sentant l'ann\u00e9e, le mois et le jour Valeur renvoy\u00e9e : bool\u00e9en indiquant si le jour est valide pour l'ann\u00e9e et le mois donn\u00e9s\"\"\" return .... def valide_naissance ( date ): \"\"\" Param\u00e8tre : date de type str au format 'ann\u00e9e-mois-jour', ex: '2002-01-07' Valeur renvoy\u00e9e : bool\u00e9en indiquant si le jour est valide pour l'ann\u00e9e et le mois donn\u00e9s \"\"\" a , m , j = date . split ( '-' ) return ...... ...... Les fonctions valide_email , valide_departement , valide_visites et valide_depenses sont fournies, compl\u00e9ter la fonction valide_enregistrement : 1 2 3 4 5 6 7 8 def valide_enregistrement ( enreg ): \"\"\" Param\u00e8tre : un enregistrement de type dictionnaire Valeur renvoy\u00e9e : bool\u00e9en indiquant si toutes les valeurs des attributs sont valides \"\"\" return ....................................................... ....................................................... ....................................................... Si un enregistrement extrait du fichier CSV est valid\u00e9, on peut convertir les valeurs de ces attributs dans le type attendu pour effectuer un traitement : int pour 'visites' et float pour 'd\u00e9penses' et str pour les autres. Compl\u00e9ter la fonction conversion_vers_table ci-dessous pour qu'elle renvoie une copie de l'enregistrement (de type dict ) pass\u00e9 en param\u00e8tre avec les types attendus pour chaque attribut. 1 2 3 4 5 6 7 8 9 def conversion_vers_table ( enregistrement ): return { 'nom' : enregistrement [ 'nom' ], 'pr\u00e9nom' : enregistrement [ 'pr\u00e9nom' ], 'email' : enregistrement [ 'email' ], 'd\u00e9partement' : enregistrement [ 'd\u00e9partement' ], 'naissance' : enregistrement [ 'naissance' ], 'visites' : ............................... , 'd\u00e9penses' : ............................... } On fournit \u00e9galement une fonction conversion_vers_fichier r\u00e9ciproque de la pr\u00e9c\u00e9dente qui convertit les valeurs de touts les attributs d'un enregistrement en type str , avant recopie de la table dans un fichier texte CSV. Compl\u00e9ter la fonction main ci-dessous, avec un code client permettant de r\u00e9aliser l'objectif fix\u00e9 en pr\u00e9ambule de l'exercice. Tester le code client pour v\u00e9rifier les postconditions. 1 2 3 4 5 6 7 8 9 10 11 12 13 def main (): \"\"\"Code client\"\"\" #Traitement / validation / filtrage table = lecture_csv ( 'clients_avec_erreurs.csv' , ',' ) table_valide = [ ..................... for enregistrement in table if ................. ] #postconditions / tests assert len ( table ) == 1000 and len ( table_valide ) == 719 assert table_valide [ 0 ] == { 'nom' : 'Bailly' , 'pr\u00e9nom' : 'Aur\u00e9lie' , 'email' : 'abailly1@gmail.com' , 'd\u00e9partement' : '22' , 'naissance' : '1986-09-22' , 'visites' : 79 , 'd\u00e9penses' : 4389.47 } table_valide_str = [ conversion_vers_fichier ( enregistrement ) for enregistrement in table_valide ] #\u00e9criture de la table valid\u00e9e ecriture_csv ( table_valide_str , 'clients_sans_erreurs.csv' , ',' ) Exercice 3 Questions type E3C On consid\u00e8re l'extraction suivante d'une base de donn\u00e9es des d\u00e9partements fran\u00e7ais. Cette extraction a ensuite \u00e9t\u00e9 sauvegard\u00e9e dans un fichier texte. 1 2 3 4 5 \"1\" , \"01\" , \"Ain\" , \"AIN\" , \"ain\" , \"A500\" \"2\" , \"02\" , \"Aisne\" , \"AISNE\" , \"aisne\" , \"A250\" \"3\" , \"03\" , \"Allier\" , \"ALLIER\" , \"allier\" , \"A460\" \"4\" , \"04\" , \"Alpes-de-Haute-Provence\" , \"ALPES-DE-HAUTE-PROVENCE\" , \"alpes-de-haute-provence\" , \"A412316152\" \"5\" , \"05\" , \"Hautes-Alpes\" , \"HAUTES-ALPES\" , \"hautes-alpes\" , \"H32412\" On consid\u00e8re le code suivant : 1 2 3 4 5 6 7 import csv f = open ( 'departements.csv' , newline = '' ) lesLignes = csv . reader ( f ) for uneLigne in lesLignes : print ( uneLigne [ 3 ]) f . close () Que va produire l'ex\u00e9cution de ce code ? R\u00e9ponse A : L'affichage de la troisi\u00e8me colonne \u00e0 savoir le nom du d\u00e9partement avec une majuscule initiale R\u00e9ponse B : L'affichage de tout le contenu du fichier R\u00e9ponse C : L'affichage du nombre total de d\u00e9partements figurant dans le fichier R\u00e9ponse D : L'affichage de la quatri\u00e8me colonne, \u00e0 savoir le nom du d\u00e9partement tout en majuscules On dispose du fichier 'info.csv' donn\u00e9 ci-dessous : 1 2 3 4 5 6 nom, prenom, naissance, deces lovelace, ada, 1815, 1852 von neumann, john, 1903, 1957 turing, alan, 1912, 1954 mccarthy, john, 1927, 2011 floyd, robert, 1936, 2001 Le programme ci-dessous nous permet de cr\u00e9er un tableau \u00e0 partir de ce fichier. 1 2 3 file = open ( \"info.csv\" , \"r\" ) firstLine = file . readline () # chargement de la ligne d'ent\u00eate tableau = [ line . split ( ',' ) for line in file ] # chargement des donn\u00e9es Les index des lignes de ce tableau vont : R\u00e9ponse A : de 0 \u00e0 3 R\u00e9ponse B : de 1 \u00e0 4 R\u00e9ponse C : de 0 \u00e0 4 R\u00e9ponse D : de 0 \u00e0 5 Quelle expression Python permet d'acc\u00e9der au num\u00e9ro de t\u00e9l\u00e9phone de Tournesol, sachant que le r\u00e9pertoire a \u00e9t\u00e9 d\u00e9fini par l'affectation suivante : 1 2 3 repertoire = [ { 'nom' : 'Dupont' , 'tel' : '5234' }, { 'nom' : 'Tournesol' , 'tel' : '5248' }, { 'nom' : 'Dupond' , 'tel' : '3452' }] R\u00e9ponse A : repertoire['Tournesol'] R\u00e9ponse B : repertoire['tel'][1] R\u00e9ponse C : repertoire[1]['tel'] R\u00e9ponse D : repertoire['Tournesol'][tel] Synth\u00e8se \u2693\ufe0e Synth\u00e8se Les tables de donn\u00e9es sont tr\u00e8s courantes : les donn\u00e9es sont organis\u00e9es en enregistrements (ligne du tableau) qui sont des p-uplets nomm\u00e9s partageant les m\u00eames attributs (ent\u00eates de colonnes dans un tableau). Les tables de donn\u00e9es sont souvent stock\u00e9es sous forme de fichiers CSV : ce sont des fichiers textes o\u00f9 les enregistrements sont des lignes dont les attributs sont s\u00e9par\u00e9s par un caract\u00e8re d\u00e9limiteur . En Python, une table contenue dans un fichier CSV peut \u00eatre repr\u00e9sent\u00e9e dans un tableau de tableaux ou plut\u00f4t un tableau de dictionnaires . Le module csv facilite les op\u00e9rations d'importation et d'exportation de tables vers des fichiers CSV . XKCD 1301","title":"Page 2"},{"location":"section/cours-tables-indexation-git/#credits","text":"Ce cours est largement inspir\u00e9 de deux sources : le chapitre 15 du manuel NSI de la collection Tortue chez Ellipse, auteurs : Ballabonski, Conchon, Filliatre, N\u2019Guyen ; le cours de Julien de Vill\u00e8le .","title":"Cr\u00e9dits"},{"location":"section/cours-tables-indexation-git/#table-de-donnees","text":"Histoire 1 L'homme organisait les donn\u00e9es sous forme de tableau bien avant l'invention de l'ordinateur : les donn\u00e9es tabulaires ou tables de donn\u00e9es , apparaissent d\u00e9j\u00e0 dans les livres de compte de l'\u00c9gypte ancienne. De nos jours les relev\u00e9s de comptes bancaires sont encore pr\u00e9sent\u00e9s sous forme de tableaux avec pour chaque op\u00e9ration sa date, sa nature (d\u00e9bit ou cr\u00e9dit) et son montant. En informatique, les tables de donn\u00e9es se sont d\u00e9velopp\u00e9es dans dans les ann\u00e9es 1970 avec l'essor des Syst\u00e8mes de Gestion de Base de Donn\u00e9es s'appuyant sur le mod\u00e8le relationnel propos\u00e9 par Edgar F. Codd chez IBM. Les Syst\u00e8mes de Gestion de Base de Donn\u00e9es permettent aujourd'hui le traitement automatique de gigantesques bases de donn\u00e9es, qui est un \u00e9l\u00e9ment fondamental dans nos soci\u00e9t\u00e9s de l'information. Les Syst\u00e8mes de Gestion de Base de Donn\u00e9es seront \u00e9tudi\u00e9s en classe de terminale. Nous pr\u00e9senterons cette ann\u00e9e les traitements de tables de donn\u00e9es qui peuvent \u00eatre effectu\u00e9s \u00e0 l'aide de scripts Python, ce qui couvre d\u00e9j\u00e0 un large champ de besoins en data science , bio-informatique , informatique financi\u00e8re ou de gestion ... D\u00e9finition 1 Une feuille de tableur est un mod\u00e8le de donn\u00e9es tabulaires ou table de donn\u00e9es . D\u00e9finissons le vocabulaire : Une table , repr\u00e9sent\u00e9e sous forme de tableau, est une collection d'\u00e9l\u00e9ments qui sont les lignes du tableau. Chaque \u00e9l\u00e9ment de la table , ou ligne de sa repr\u00e9sentation sous forme de tableau, s'appelle un enregistrement . Tous les enregistrements d'une m\u00eame table sont des p-uplets nomm\u00e9s qui partagent les m\u00eames descripteurs , appel\u00e9s aussi attributs . Dans une repr\u00e9sentation de la table sous forme de tableau, chaque attribut correspond \u00e0 une colonne. Chaque attribut est caract\u00e9ris\u00e9 par son type et son domaine de valeurs . Dans une repr\u00e9sentation sous forme de tableau, les descripteurs ou attributs sont en g\u00e9n\u00e9ral plac\u00e9s comme en-t\u00eate de colonnes sur la premi\u00e8re ligne. Example 1 La table repr\u00e9sent\u00e9e ci-dessus rassemble les enregistrements des clients d'un site web marchand. Les attributs de cette table sont : le nom et le pr\u00e9nom du client de type cha\u00eene de caract\u00e8res l'adresse mail du client du type cha\u00eene de caract\u00e8res avec un domaine de valeurs particulier le d\u00e9partement du client du type cha\u00eene de caract\u00e8res avec un domaine de valeurs particulier le nombre de visites du client de type entier avec pour domaine de valeurs les entiers positifs les d\u00e9penses du client de type flottant avec pour domaine de valeurs les flottants positifs","title":"Table de donn\u00e9es"},{"location":"section/cours-tables-indexation-git/#echange-de-table-de-donnees-avec-un-fichier-csv","text":"Point de cours1 Pour \u00e9changer des donn\u00e9es tabulaires entre les programmes qui doivent les manipuler, on les exporte puis les importe sous la forme de fichiers textes, c'est-\u00e0-dire lisibles par l'\u00eatre humain. Afin d'assurer l'interop\u00e9rabilit\u00e9 entre diff\u00e9rents programmes, un fichier doit respecter un format normalis\u00e9. L'un des formats les plus r\u00e9pandus pour l'\u00e9change de donn\u00e9es tabulaires est le format CSV pour Comma Separated Values : un fichier CSV est un fichier texte donc \u00e9ditable avec un \u00e9diteur de textes comme Notepad++ ; chaque ligne du fichier correspond \u00e0 un enregistrement de la table pour un enregistrement donn\u00e9, les valeurs des diff\u00e9rents attributs sont s\u00e9par\u00e9es en champs par un d\u00e9limiteur qui est en g\u00e9n\u00e9ral l'un des symboles , ou ; ou : . la premi\u00e8re ligne contient en g\u00e9n\u00e9ral les noms des attributs . les champs peuvent \u00eatre d\u00e9limit\u00e9s par des guillemets droits \" s'ils contiennent du texte avec des espaces ou des sauts de ligne. Le caract\u00e8re \" est alors \u00e9chapp\u00e9 en \"\" pour le distinguer des guillemets droits d\u00e9limiteurs. Voici un extrait d'un fichier CSV correspondant \u00e0 la table pr\u00e9sent\u00e9e dans l'exemple 1 : 1 2 3 4 5 nom,pr\u00e9nom,email,d\u00e9partement,naissance,visites,d\u00e9penses Gomes,Brigitte,bgomes@laposte.net,79,1960-08-21,67,8342.99 Nicolas,Georges,gnicolas@yahoo.fr,10,1994-05-26,86,10908.08 Berger,P\u00e9n\u00e9lope,pberger@noos.fr,73,2001-03-01,131,3817.79 Charrier,Richard,rcharrier@sfr.fr,2B,1977-08-07,16,997.09 On donne ci-dessous un autre extrait de fichier CSV qui est un export de fichier d'identifiants de l'Espace Num\u00e9rique de Travail (avec valeurs modifi\u00e9es). La table comporte 19 attributs de rne \u00e0 pays list\u00e9s sur la premi\u00e8re ligne. Le premier enregistrement figure sur la deuxi\u00e8me ligne avec pour valeur du premier champ 0690026D et sept champs vides \u00e0 la fin. On observe que le d\u00e9limiteur de champ est le symbole ; , que les champs peuvent contenir des espaces, que certains sont vides et que le nombre de champs pour le premier enregistrement ne correspond pas au nombre d'attributs ! On peut imaginer que pour traiter un tel fichier avec un programme, il faut d'abord analyser sa structure, ses particularit\u00e9s et pr\u00e9voir d'\u00e9ventuelles irr\u00e9gularit\u00e9s dans les donn\u00e9es (absence, erreurs de type, de saisie, corruption du fichier ...). Le contr\u00f4le de la validit\u00e9 des donn\u00e9es doit donc \u00eatre une composante du programme de traitement. 1 2 rne;uid;classe;profil;prenom;nom;login;mot de passe;cle de jointure;uid pere;uid mere;uid tuteur1;uid tuteur2;prenom enfant;nom enfant;adresse;code postal;ville;pays 0690026D;WKZ08710;813;Eleve;Mathieu;DUPONT;mathieu.dupont;>>>> Mot de passe d\u00e9j\u00e0 modifi\u00e9 par utilisateur >>>>;AC-LYON$3780909;WKZ02158;WKZ02171;;;;;;;; Exercice 1 Questions type E3C Dans la plupart des fichiers CSV, que contient la premi\u00e8re ligne ? R\u00e9ponse A : des notes concernant la table de donn\u00e9es R\u00e9ponse B : les sources des donn\u00e9es R\u00e9ponse C : les descripteurs des champs de la table de donn\u00e9es R\u00e9ponse D : l'auteur de la table de donn\u00e9es Laquelle de ces affirmations est vraie ? R\u00e9ponse A : on ne peut acc\u00e9der au contenu d'un fichier CSV que par l'interm\u00e9diaire d'un programme Python R\u00e9ponse B : CSV est un format de chiffrement des donn\u00e9es R\u00e9ponse C : le format CSV a \u00e9t\u00e9 con\u00e7u pour assurer la confidentialit\u00e9 d'une partie du code d'un programme R\u00e9ponse D : les fichiers CSV sont compos\u00e9s de donn\u00e9es s\u00e9par\u00e9es par des caract\u00e8res comme des virgules Qu'est-ce que le format de fichier CSV ? R\u00e9ponse A : un format de fichier mis au point par Microsoft pour Excel R\u00e9ponse B : un format de fichier pour d\u00e9crire une base de donn\u00e9e R\u00e9ponse C : un format de fichier o\u00f9 les donn\u00e9es sont s\u00e9par\u00e9es par un caract\u00e8re tel qu'une virgule R\u00e9ponse D : un format de fichier d\u00e9crivant une page Web","title":"\u00c9change de table de donn\u00e9es avec un fichier CSV"},{"location":"section/cours-tables-indexation-git/#manipulation-de-fichiers-csv-en-python","text":"D\u00e9finition 2 L'indexation de table est la cr\u00e9ation d'une structure de donn\u00e9es \u00e0 partir de donn\u00e9es tabulaires. Nous allons pr\u00e9senter quelques m\u00e9thodes d'indexation de table extraite d'un fichier CSV vers une structure de donn\u00e9es du langage Python : tableau de tableaux ou tableau de dictionnaires que nous privil\u00e9gierons. Dans cette section, on consid\u00e8re le fichier CSV , clients_mini.csv , repr\u00e9sentant un extrait de la table de l\u2019exemple 1 avec les enregistrements de 20 clients d\u2019un site web marchand. M\u00e9thode 1 Pr\u00e9sentons deux m\u00e9thodes de lecture de fichiers CSV qui utilisent les outils standards de Python. On fait les hypoth\u00e8ses suivantes : la premi\u00e8re ligne du fichier contient les attributs et on conna\u00eet le d\u00e9limiteur, ici le symbole , . Lecture On peut extraire les attributs et la table contenus dans le fichier clients_mini.csv avec le code ci-dessous : 1 2 3 4 fichier = open ( 'clients_mini.csv' , encoding = 'utf8' , newline = '' ) #ouverture du fichier attributs = fichier . readline () . rstrip () . split ( ',' ) #extraction de la ligne des attributs table = [ ligne . rstrip () . split ( ',' ) for ligne in fichier ] #extraction des autres lignes fichier . close () #fermeture du fichier La m\u00e9thode open permet de cr\u00e9er un objet fichier qu'on peut parcourir ligne par ligne avec un curseur : d'abord la premi\u00e8re ligne avec fichier.readline() puis les lignes suivantes en it\u00e9rant sur fichier . Il est important de pr\u00e9ciser l'encodage du fichier , par d\u00e9faut c'est celui du syst\u00e8me d'exploitation. Chaque ligne est une cha\u00eene de caract\u00e8res d\u00e9coup\u00e9e en liste de champs selon le d\u00e9limiteur pass\u00e9 en param\u00e8tre \u00e0 la m\u00e9thode split . Le caract\u00e8re de saut de lignes a d'abord \u00e9t\u00e9 supprim\u00e9 avec la m\u00e9thode rstrip . On r\u00e9cup\u00e8re ainsi les attributs comme un tableau de type list et la table comme un tableau d'enregistrements qui sont eux-m\u00eames des tableaux. Notons que toutes les valeurs sont des cha\u00eenes de caract\u00e8res et qu'il faudra convertir certaines pour les traiter ! 1 2 3 4 5 6 >>> attributs #tableau des attributs [ 'nom' , 'pr\u00e9nom' , 'email' , 'd\u00e9partement' , 'naissance' , 'visites' , 'd\u00e9penses' ] >>> table [ 0 ] #tableau premier enregistrement [ 'Gomes' , 'Brigitte' , 'bgomes@laposte.net' , '79' , '1960-08-21' , '67' , '8342.99' ] >>> table [: 2 ] #tableau de tableaux : extrait [[ 'Gomes' , 'Brigitte' , 'bgomes@laposte.net' , '79' , '1960-08-21' , '67' , '8342.99' ], [ 'Nicolas' , 'Georges' , 'gnicolas@yahoo.fr' , '10' , '1994-05-26' , '86' , '10908.08' ]] \u00c9criture On peut ensuite recopier les attributs et la table dans un autre fichier clients_mini_copie.csv avec le code ci-dessous : 1 2 3 4 5 6 g = open ( 'clients_mini_copie.csv' , encoding = 'utf8' , newline = '' ) premiere_ligne = ',' . join ( attributs ) + ' \\n ' g . write ( premiere_ligne ) for enregistrement in table : g . write ( ',' . join ( enregistrement ) + ' \\n ' ) g . close () La m\u00e9thode join permet de concat\u00e9ner les \u00e9l\u00e9ments d'un tableau de cha\u00eenes de caract\u00e8res avec un d\u00e9limiteur. Avec ces m\u00e9thodes, une table est donc repr\u00e9sent\u00e9e par un tableau de tableaux . On acc\u00e8de \u00e0 un enregistrement par son index dans la table et \u00e0 la valeur d'un attribut par son index dans le tableau des attributs (s\u00e9par\u00e9 de la table). C'est incommode et le code produit est peu lisible. Ainsi, pour acc\u00e9der \u00e0 l'adresse mail du premier enregistrement il faut saisir table[0][2] . On aimerait \u00e9crire table[0]['email'] . Pour cela, chaque enregistrement devrait \u00eatre un dictionnaire avec pour clefs les attributs de la table. C'est possible en utilisant le module csv . M\u00e9thode 2 Le module csv est disponible dans la biblioth\u00e8que standard et peut donc \u00eatre utilis\u00e9 sans installation sp\u00e9cifique. \u00c0 partir de la table contenu dans le m\u00eame fichier CSV 'clients_mini.csv' , ce module permet de cr\u00e9er une structure de donn\u00e9es d'un acc\u00e8s plus facile. Lecture Le code ci-dessous permet d'extraire directement la table d'un fichier CSV dans une structure de donn\u00e9es qui est un tableau de dictionnaires : chaque enregistrement est un dictionnaire dont les clefs sont les attributs list\u00e9s sur la premi\u00e8re ligne du fichier. Pour les versions de Python 3.6 et 3.7 uniquement, les dictionnaires renvoy\u00e9s sont sp\u00e9cifiques, de type OrderedDict , et on prendra soin de les convertir en dictionnaires standard avec dict . 1 2 3 4 5 6 import csv # import du module f = open ( 'clients_mini.csv' , mode = 'r' , encoding = 'utf8' , newline = '' ) reader = csv . DictReader ( f , delimiter = ',' ) #cr\u00e9ation d'un objet reader table = [ dict ( enregistrement ) for enregistrement in reader ] f . close () La structure de donn\u00e9es repr\u00e9sentant la table est un tableau de dictionnaires : l'acc\u00e8s aux enregistrements se fait par index et \u00e0 leurs attributs par clef : tr\u00e8s efficace (co\u00fbt constant) et code lisible. Notons que toutes les valeurs restent des cha\u00eenes de caract\u00e8res et qu'il faudra convertir certaines pour les traiter ! 1 2 3 4 5 6 7 8 >>> table [ 0 ] #premier enregistrement de type dictionnaire { 'nom' : 'Gomes' , 'pr\u00e9nom' : 'Brigitte' , 'email' : 'bgomes@laposte.net' , 'd\u00e9partement' : '79' , 'naissance' : '1960-08-21' , 'visites' : '67' , 'd\u00e9penses' : '8342.99' } >>> table [: 2 ] # tableu de dictionnaires : extrait [{ 'nom' : 'Gomes' , 'pr\u00e9nom' : 'Brigitte' , 'email' : 'bgomes@laposte.net' , 'd\u00e9partement' : '79' , 'naissance' : '1960-08-21' , 'visites' : '67' , 'd\u00e9penses' : '8342.99' }, { 'nom' : 'Nicolas' , 'pr\u00e9nom' : 'Georges' , 'email' : 'gnicolas@yahoo.fr' , 'd\u00e9partement' : '10' , 'naissance' : '1994-05-26' , 'visites' : '86' , 'd\u00e9penses' : '10908.08' }] >>> len ( table ) 20 >>> table [ 0 ][ 'email' ] #acc\u00e8s facile aux valeurs des attibuts par clefs 'bgomes@laposte.net' \u00c9criture L'\u00e9criture d'un tableau de dictionnaires partageant les m\u00eames clefs sous forme de table dans un fichier CSV, s'effectue de fa\u00e7on sym\u00e9trique \u00e0 travers un objet DictWriter . \u00c0 titre, d'exemple, on recopie la table extraite pr\u00e9c\u00e9demment dans un autre fichier CSV. Depuis Python 3.7, le parcours des clefs d'un dictionnaire est garanti dans le m\u00eame ordre que celui d'insertion donc on peut r\u00e9cup\u00e9rer la liste des attributs avec list(table[0].keys()) 1 2 3 4 5 6 7 g = open ( 'clients_mini_copie2.csv' , mode = 'w' , encoding = 'utf8' , newline = '' ) attributs = list ( table [ 0 ] . keys ()) writer = csv . DictWriter ( g , delimiter = ',' , fieldnames = attributs ) #cr\u00e9ation de l'objet writer writer . writeheader () #\u00e9criture des attributs for enregistrement in table : writer . writerow ( enregistrement ) #\u00e9criture des enregistrements g . close () Remarque Le module csv permet aussi d'extraire une table d'un fichier CSV sous forme de tableau de tableaux comme dans la m\u00e9thode pr\u00e9c\u00e9dente. Le d\u00e9coupage des lignes/enregistrements selon le d\u00e9limiteur est int\u00e9gr\u00e9 ce qui simplifie le code. 1 2 3 4 f = open ( 'clients_mini.csv' , mode = 'r' , encoding = 'utf8' , newline = '' ) reader = csv . reader ( f , delimiter = ',' ) table = [ ligne for ligne in reader ] f . close () Exercice 2 Le fichier clients_avec_erreurs.csv contient une table de la m\u00eame structure que celle de l'exemple 1 mais avec des donn\u00e9es invalides : pour l'attribut 'email' : format incorrect ou adresse manquante pour l'attribut 'd\u00e9partement' : valeur incorrecte pour l'attribut 'naissance' : ann\u00e9e hors post\u00e9rieure \u00e0 2005 (pas de clients de moins de 15 ans !), mois hors de la plage [1,12], jour hors de la plage possible pour l'ann\u00e9e et le mois fix\u00e9. pour les attributs : 'visites' et ' d\u00e9penses ' : valeurs n\u00e9gatives L'objectif de cet exercice est d'extraire la table du fichier, de filtrer les enregistrements valides et de les recopier dans un fichier 'clients_sans_erreurs.csv' . Ouvrir le fichier cours_exercices_tables_eleve.py dans un IDE Python. Compl\u00e9ter les fonctions de lecture / \u00e9criture d'une table repr\u00e9sent\u00e9e par un tableau de dictionnaires vers un fichier CSV : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def lecture_csv ( fichier , delimiteur ): f = open ( fichier , mode = 'r' , encoding = 'utf8' , newline = '' ) reader = csv . DictReader ( f , delimiter = delimiteur ) f . close () return table def ecriture_csv ( table , fichier , delimiteur ): g = open ( fichier , mode = 'w' , encoding = 'utf8' , newline = '' ) attributs = list ( table [ 0 ] . keys ()) writer = csv . DictWriter ( g , delimiter = delimiteur , fieldnames = attributs ) g . close () Compl\u00e9ter les fonctions bissextile , valide_mois , valide_jour puis la fonction valide_naissance . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def bissextile ( a ): \"\"\"Param\u00e8tre : a de type int repr\u00e9sentant une ann\u00e9e Valeur renvoy\u00e9e : bool\u00e9en indiquant si l'ann\u00e9e est bissextile\"\"\" return ..... def valide_annee ( j ): return 1900 <= j <= 2005 def valide_mois ( m ): \"\"\"Param\u00e8tre : m de type int repr\u00e9sentant un mois Valeur renvoy\u00e9e : bool\u00e9en indiquant si le mois est valide (entre 1 et 12)\"\"\" return .... def valide_jour ( a , m , j ): \"\"\"Param\u00e8tre : a, m, j de type int repr\u00e9sentant l'ann\u00e9e, le mois et le jour Valeur renvoy\u00e9e : bool\u00e9en indiquant si le jour est valide pour l'ann\u00e9e et le mois donn\u00e9s\"\"\" return .... def valide_naissance ( date ): \"\"\" Param\u00e8tre : date de type str au format 'ann\u00e9e-mois-jour', ex: '2002-01-07' Valeur renvoy\u00e9e : bool\u00e9en indiquant si le jour est valide pour l'ann\u00e9e et le mois donn\u00e9s \"\"\" a , m , j = date . split ( '-' ) return ...... ...... Les fonctions valide_email , valide_departement , valide_visites et valide_depenses sont fournies, compl\u00e9ter la fonction valide_enregistrement : 1 2 3 4 5 6 7 8 def valide_enregistrement ( enreg ): \"\"\" Param\u00e8tre : un enregistrement de type dictionnaire Valeur renvoy\u00e9e : bool\u00e9en indiquant si toutes les valeurs des attributs sont valides \"\"\" return ....................................................... ....................................................... ....................................................... Si un enregistrement extrait du fichier CSV est valid\u00e9, on peut convertir les valeurs de ces attributs dans le type attendu pour effectuer un traitement : int pour 'visites' et float pour 'd\u00e9penses' et str pour les autres. Compl\u00e9ter la fonction conversion_vers_table ci-dessous pour qu'elle renvoie une copie de l'enregistrement (de type dict ) pass\u00e9 en param\u00e8tre avec les types attendus pour chaque attribut. 1 2 3 4 5 6 7 8 9 def conversion_vers_table ( enregistrement ): return { 'nom' : enregistrement [ 'nom' ], 'pr\u00e9nom' : enregistrement [ 'pr\u00e9nom' ], 'email' : enregistrement [ 'email' ], 'd\u00e9partement' : enregistrement [ 'd\u00e9partement' ], 'naissance' : enregistrement [ 'naissance' ], 'visites' : ............................... , 'd\u00e9penses' : ............................... } On fournit \u00e9galement une fonction conversion_vers_fichier r\u00e9ciproque de la pr\u00e9c\u00e9dente qui convertit les valeurs de touts les attributs d'un enregistrement en type str , avant recopie de la table dans un fichier texte CSV. Compl\u00e9ter la fonction main ci-dessous, avec un code client permettant de r\u00e9aliser l'objectif fix\u00e9 en pr\u00e9ambule de l'exercice. Tester le code client pour v\u00e9rifier les postconditions. 1 2 3 4 5 6 7 8 9 10 11 12 13 def main (): \"\"\"Code client\"\"\" #Traitement / validation / filtrage table = lecture_csv ( 'clients_avec_erreurs.csv' , ',' ) table_valide = [ ..................... for enregistrement in table if ................. ] #postconditions / tests assert len ( table ) == 1000 and len ( table_valide ) == 719 assert table_valide [ 0 ] == { 'nom' : 'Bailly' , 'pr\u00e9nom' : 'Aur\u00e9lie' , 'email' : 'abailly1@gmail.com' , 'd\u00e9partement' : '22' , 'naissance' : '1986-09-22' , 'visites' : 79 , 'd\u00e9penses' : 4389.47 } table_valide_str = [ conversion_vers_fichier ( enregistrement ) for enregistrement in table_valide ] #\u00e9criture de la table valid\u00e9e ecriture_csv ( table_valide_str , 'clients_sans_erreurs.csv' , ',' ) Exercice 3 Questions type E3C On consid\u00e8re l'extraction suivante d'une base de donn\u00e9es des d\u00e9partements fran\u00e7ais. Cette extraction a ensuite \u00e9t\u00e9 sauvegard\u00e9e dans un fichier texte. 1 2 3 4 5 \"1\" , \"01\" , \"Ain\" , \"AIN\" , \"ain\" , \"A500\" \"2\" , \"02\" , \"Aisne\" , \"AISNE\" , \"aisne\" , \"A250\" \"3\" , \"03\" , \"Allier\" , \"ALLIER\" , \"allier\" , \"A460\" \"4\" , \"04\" , \"Alpes-de-Haute-Provence\" , \"ALPES-DE-HAUTE-PROVENCE\" , \"alpes-de-haute-provence\" , \"A412316152\" \"5\" , \"05\" , \"Hautes-Alpes\" , \"HAUTES-ALPES\" , \"hautes-alpes\" , \"H32412\" On consid\u00e8re le code suivant : 1 2 3 4 5 6 7 import csv f = open ( 'departements.csv' , newline = '' ) lesLignes = csv . reader ( f ) for uneLigne in lesLignes : print ( uneLigne [ 3 ]) f . close () Que va produire l'ex\u00e9cution de ce code ? R\u00e9ponse A : L'affichage de la troisi\u00e8me colonne \u00e0 savoir le nom du d\u00e9partement avec une majuscule initiale R\u00e9ponse B : L'affichage de tout le contenu du fichier R\u00e9ponse C : L'affichage du nombre total de d\u00e9partements figurant dans le fichier R\u00e9ponse D : L'affichage de la quatri\u00e8me colonne, \u00e0 savoir le nom du d\u00e9partement tout en majuscules On dispose du fichier 'info.csv' donn\u00e9 ci-dessous : 1 2 3 4 5 6 nom, prenom, naissance, deces lovelace, ada, 1815, 1852 von neumann, john, 1903, 1957 turing, alan, 1912, 1954 mccarthy, john, 1927, 2011 floyd, robert, 1936, 2001 Le programme ci-dessous nous permet de cr\u00e9er un tableau \u00e0 partir de ce fichier. 1 2 3 file = open ( \"info.csv\" , \"r\" ) firstLine = file . readline () # chargement de la ligne d'ent\u00eate tableau = [ line . split ( ',' ) for line in file ] # chargement des donn\u00e9es Les index des lignes de ce tableau vont : R\u00e9ponse A : de 0 \u00e0 3 R\u00e9ponse B : de 1 \u00e0 4 R\u00e9ponse C : de 0 \u00e0 4 R\u00e9ponse D : de 0 \u00e0 5 Quelle expression Python permet d'acc\u00e9der au num\u00e9ro de t\u00e9l\u00e9phone de Tournesol, sachant que le r\u00e9pertoire a \u00e9t\u00e9 d\u00e9fini par l'affectation suivante : 1 2 3 repertoire = [ { 'nom' : 'Dupont' , 'tel' : '5234' }, { 'nom' : 'Tournesol' , 'tel' : '5248' }, { 'nom' : 'Dupond' , 'tel' : '3452' }] R\u00e9ponse A : repertoire['Tournesol'] R\u00e9ponse B : repertoire['tel'][1] R\u00e9ponse C : repertoire[1]['tel'] R\u00e9ponse D : repertoire['Tournesol'][tel]","title":"Manipulation de fichiers CSV en Python"},{"location":"section/cours-tables-indexation-git/#synthese","text":"Synth\u00e8se Les tables de donn\u00e9es sont tr\u00e8s courantes : les donn\u00e9es sont organis\u00e9es en enregistrements (ligne du tableau) qui sont des p-uplets nomm\u00e9s partageant les m\u00eames attributs (ent\u00eates de colonnes dans un tableau). Les tables de donn\u00e9es sont souvent stock\u00e9es sous forme de fichiers CSV : ce sont des fichiers textes o\u00f9 les enregistrements sont des lignes dont les attributs sont s\u00e9par\u00e9s par un caract\u00e8re d\u00e9limiteur . En Python, une table contenue dans un fichier CSV peut \u00eatre repr\u00e9sent\u00e9e dans un tableau de tableaux ou plut\u00f4t un tableau de dictionnaires . Le module csv facilite les op\u00e9rations d'importation et d'exportation de tables vers des fichiers CSV . XKCD 1301","title":"Synth\u00e8se"}]}